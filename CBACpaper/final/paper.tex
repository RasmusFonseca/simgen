\documentclass[review]{elsarticle}

\usepackage{latex/subfigure}
\usepackage{latex/multirow}
\usepackage{epsfig}

\usepackage{lineno,hyperref}
\modulolinenumbers[5]

\usepackage{latex/fancyvrb}
\usepackage{latex/caption}
%\usepackage{latex/caption3}

\include{latex/header}
\newcommand{\TT}[1]{{\ttfamily\bfseries #1}}
\newcommand{\Tt}[1]{{\tt #1}}
\newcommand{\NAME}{{\TT{SimGen}}}

\journal{Computational Biology and Chemistry}

%%%%%%%%%%%%%%%%%%%%%%%
%% Elsevier bibliography styles
%%%%%%%%%%%%%%%%%%%%%%%
%% To change the style, put a % in front of the second line of the current style and
%% remove the % from the second line of the style you would like to use.
%%%%%%%%%%%%%%%%%%%%%%%

%% Numbered
%\bibliographystyle{model1-num-names}

%% Numbered without titles
%\bibliographystyle{model1a-num-names}

%% Harvard
%\bibliographystyle{model2-names.bst}\biboptions{authoryear}

%% Vancouver numbered
%\usepackage{numcompress}\bibliographystyle{model3-num-names}

%% Vancouver name/year
%\usepackage{numcompress}\bibliographystyle{model4-names}\biboptions{authoryear}

%% APA style
%\bibliographystyle{model5-names}\biboptions{authoryear}

%% AMA style
%\usepackage{numcompress}\bibliographystyle{model6-num-names}

%% `Elsevier LaTeX' style
\bibliographystyle{elsarticle-num}
%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{frontmatter}

\title{
Steric exclusion and constraint satisfaction in multi-scale coarse-grained simulations
}

%% Group authors per affiliation:
\author{
William R.~Taylor
}
\address{
Francis Crick Institute, 1 Midland Rd., London NW1 1AT, UK
}

\begin{abstract}
An algorithm is described for the interaction of a hierarchy of objects that seeks to circumvent a fundamental problem in coarse-grained modelling which is the loss of fine detail when components become bundled together. A "currants-in-jelly" model is developed that provides a flexible approach in which the contribution of the soft high-level objects (jelly-like) are employed to protect the underlying atomic structure (currants), while still allowing them to interact. Idealised chains were used to establish the parameters to achieve this degree of interaction over a hierarchy spanning four levels and in a more realistic example, the distortion experienced by a protein domain structure during collision was measured and the parameters refined. This model of steric repulsion was then combined with sets of predicted distance constraints, derived from correlated mutation analysis. Firstly, an integral trans-membrane protein was modelled in which the packing of the seven helices was refined but without topological rearrangement. Secondly, an RNA structure was 'folded' under the predicted constraints, starting only from its 2-dimensional secondary structure prediction. 
\end{abstract}

\begin{keyword}
coarse-grained molecular modelling\sep steric-exclusion\sep constraint satisfaction
\end{keyword}

\end{frontmatter}

\linenumbers

%\section{Overview and Model Design}
%\include{intro}
%\section{Algorithms and Implementation}
%\include{bumper}
%\include{keeper}
%\include{linker}
%\section{Examples and Applications}
%\include{test}
%\include{real}
%\section{Summary and Discussion}
%\include{final}

\clearpage
\section{Overview and Model Design}

\subsection{Overview}

\subsubsection{Introduction}

Molecular simulation methods are increasingly being applied to ever larger systems.
However, given finite computational resources, there is inevitably a limit to the size of
the system that can be simulated in a reasonable time.   Besides buying bigger computers, approaches to 
circumvent this limitation generally follow the original approach of Levitt and Warshel
\cite{LevittMet75}
and reduce the number of simulated particles by combining groups of atoms, such as an
amino acid side-chain, into a single pseudo-atom with a spherical radius that
reflects the volume of the combined atoms
\cite{BondPJet07,IzvekovSet05}.  (See Ref.\cite{TozziniV05} for a review).
This coarse-grained approach suffers from the problem that as the number of combined
atoms increases in number, so their representation becomes less realistic.  Taken
to an extreme degree, if a protein is represented by a single sphere, then all 
the details of its structure become hidden.  

In this work, I describe the development of an earlier algorithm for collision 
detection between groups of multiple points 
\cite{KatsimitsouliaZet10a,TaylorWRet10a}
into a general method that allows
points (atoms\footnote{
In the following description the use of the terms "atom" and "atomic" are used
only to indicate the lowest level in a hierarchy of objects (the leaf nodes).
Although they are restricted to a spherical shape they do not necessarily
represents atoms (in the phyico-chemical sense). 
}) to be contained within a variety of shapes but still retaining the 
property that the interaction (or collision) of these higher-level objects is based
on contact between their component atoms.
The approach follows a divide-and-conquer strategy in which the problem of
dealing with a quadratic computational complexity in the number of points
is reduced by partitioning the interactions into a series of grouped interactions
on a hierarchic tree.

\subsubsection{Hierarchic collision detection}

Fast collision detection in interactive computer game simulations is enabled by the
use of a bounding-box construct \cite{TeschnerMet05}.  This is a box in which a group of points is contained
and the calculation of the interactions between points in different boxes is not
evaluated until their boxes overlap.    This approach is similar to, but distinct from,
the use of neighbour-lists in molecular dynamics (MD) \cite{VerletL67}.   In general, the bounding
box can be any shape but should, ideally have a simple shape to allow for fast
overlap calculation.    The advantage of a box that is aligned with the coordinate
frame is that only X,Y,Z values need be compared, without the more costly calculation
of a 3D distance. Unfortunately, unlike objects in computer games, in the molecular
world the dominant orientation dictated by gravity is absent so a construct based
on the "world" coordinate frame is less relevant.  (See Ref.\cite{MuthBet07} for a review).

Previously, this approach was used to speed collision detection
between atoms using a simple spherical "box" \cite{TaylorWRet10a}
but when dealing with non-spherical objects,
such as alpha-helices of nucleic acid segments, a sphere is not an ideal shape and
when made large enough to enclose an elongated object many other objects can be
brought into the calculation even when they are far from interacting, especially if
they too are elongated.   In this work, the original method based on spheres is
extended to a wider variety of shapes and into a generalised hierarchy in which the
boxes themselves can be assigned different collision properties at any level in the
hierarchy. 

For example; attributing a box object with hard-shell collision behaviour is equivalent to
ignoring all their internal components when two objects collide.    If this absolute
degree of repulsion is softened, then the objects can now partly interpenetrate,
allowing their internal components to come into contact, with their own collision
properties contributing to the interaction.   If the high-level objects do not
repel at all, then all repulsion will be determined by the structure and properties of
the internal components.

Through this approach, the coarse-grained representation at the high-level does not
completely mask the details of the interaction at the lower level, however, it is still being
used to save computation time, especially where it retains a good shape-match to the
interacting surface of its components.


\subsection{Model specification}

\subsubsection{Object descriptions}
 
The choice of shapes for the higher level objects (or containers) is, in principle, not
limited but simple shapes have been chosen that reflect those encountered in biomolecular
models.   These include a sphere, which can be generalised as an oblate or prolate
ellipsoid\footnote{
Oblate and prolate ellipsoids, which have two equal axes (and hence a unique axis of symmetry)
are referred to jointly as spheroids, with scalene being the remaining asymmetric type.  
However, to avoid confusion with spherical objects, the term will be avoided.}
(but not scalene, as will be discussed below) and a tube (or more precisely, a fixed-length
straight section of pipe with hemi-spherical end-caps).  Both spheres and tubes have been
used widely in coarse-grainned modelling, with the latter being a good representation
for an RNA stem-loop \cite{DingFet08} or an \AH\ \cite{MinaryPet10} or even a general peptide \cite{VachaRet14}.

Objects at any level can adopt any mix of these basic shapes which can be different 
sizes and for ellipsoids, have different degrees of eccentricity (from "cigar" to "flying 
saucer"), similarly, tubes can have differing length:radius ratios (from "coin" to "pencil").
However, as tubes have hemispherical end-caps, they approach a spherical shape as their
length decreases, as do ellipsoids as their axes become equal.
For each of these objects and their pairwise interactions, it is necessary to have 
a fast algorithm to compute their surface and the point at which their surfaces
make contact.   For spheres, both these are trivial and between fixed-length straight
tubes, both with themselves and spheres, the calculations require only slightly more
"book-keeping".    However, the interaction of ellipsoids is less simple and an analytic
solution for the contact-normal between two ellipsoids is not trivial \cite{DonevAet04b,KallrathJ15}.

\subsubsection{Coupling the levels}

It would be of little use if objects were to wander outside their container as their
interactions would not be detected until their containers eventually made contact.
Although this might be avoided or reduced by having a large container, for computational
efficiency, it is better if the container maintains a close fit to its contents.

The task of ensuring a good match between the parent container and its enclosed
children was obtained it two main ways: firstly, by maintaining the centre of the
parent container at the centroid of its children and secondly, by applying any
displacement or rotation of the parent automatically to all its children and recursively
to any children that they also contain.   However, while these two conditions serve
to synchronise the motion between levels, they do not prevent the escape of children
through isotropic diffusion.   This was tackled directly by applying a corrective push
to return any wayward children back into the parental fold.   With a few minor elaborations
described below, these couplings constitute the only direct connection between levels in the
hierarchy of objects as no collisions are calculated between objects at different levels.

Despite their simplicity, these couplings are sufficient to generate appropriate
behaviour during collisions.   For example; if at one extreme, the parent shapes interact
as hard surfaces then in a collision, all their contents will move with them during
recoil.   At the other extreme, if the parents have no repulsion but their children do,
then the parent containers will interpenetrate, allowing collisions to occur between
the children which will repel each other and as a result, their centroids will 
separate, with the centres of their parents tracking this displacement.   In the intermediate
situation, where the parents retain some repulsive behaviour, their inter-penetration
will be reduced like the collision of two soft bodies but retaining the hard-shell
repulsion between children.   

An option was added to exaggerate this "currants-in-jelly" collision model by making
the soft parental repulsion dependent on the number of colliding children.   This
allows two parental containers to pass through each other undeflected until their
children clash: at which point the parental repulsion becomes active and guides the
two families of points apart before extensive interaction occurs between the 
children.   Such behaviour prevents the separation of the parents being completely
dependent on the displacement of the children as in high speed\footnote{
The term "speed" is used throught to refer to the step size per cycle of any
geometric transformation.   As the stepsize is not related to any physical
process, it does not have any implications for biological macromolecules.
}
collisions, any
internal structure within the children can be disrupted before separation is attained.

A further safeguard was introduced to deal with the possible situation where two
families of points have collided and overlapped to such an extent that there is no
dominant direction of separation provided by the children.   To avoid this family
grid-lock, children with different parents were not repelled along their contact
normal but each was given an additional vectorial component back towards their
parental centre.

\subsubsection{Parental realignment}

The way in which parents track their children was described above only in terms of
translation, but for objects other that the sphere, a rotational realignment must also
be considered.   Any parental rotation is automatically communicated to its children but
a rotation of the children, either caused randomly or by a push or pull on a group of
bonded children, does not get communicated up to the parent in the same way.

However, for both the ellipsoid and tube, there is a unique axis of symmetry and this can
be recalculated from the configuration of the children.  If the children are bonded
in a chain then the axis can be reset simply by considering a small group of positions
around the termini (or jointly the complementary $5',3'$ pairs in double-stranded
nucleic acids).   More generally, the axis can be recalculated from the moments
of inertia of the point set, irrespective of their connectivity.
This computationally more expensive calculation was made much less frequently
compared to the positional tracking up-date. 

\subsection{Shape correspondence to molecular objects}

Although the mapping of the objects described above to molecular substructures is quite
arbitrary and could be devised "from scratch" with each application, there are some
natural associations and in the program that implements the methods (called \NAME),
the construction of these have been facilitated by specialised routines that parse
the input stream. (See \cite{TaylorWRet12c} for an outline).

\subsubsection{Proteins}

The "atomic" level for protein structure is assumed to be the chain constructed on
consecutive \CA\ positions.   By default, the atomic level is always a hard-sphere
and in the internal coordinate representation of 0.6 units to 3.8\AA\ (the \CA--\CA\
'bond' distance), the bump-radius is set to 3 which is the closest approach distance 
between positions i and i+2.   Bonded positions (i, i+1) do not bump.  

The natural object to represent secondary structure elements is a tube.   Preset
length:radius ratios are adopted for alpha, beta and coil structures with the ratio
determined by the axial displacement per residue for each secondary structure which
is 1.5 and 3.0 for alpha and beta, respectively.   Given the more irregular nature
of the coil regions, an arbitrary value of 0.5 was used but the coil residues were
only weakly constrained to keep within this (short) tube.

Domain level structure is best represented by an ellipsoid \cite{TaylorWRet83b}.  
Although the average domain shape is a scalene ellipsoid (semi-axes A$\ne$B$\ne$C)
\cite{AszodiAet94a}, the program picks
the closest symmetric prolate ellipsoid (A$\ne$B=C) or oblate ellipsoid (A=B$\ne$C).

The overall protein envelope (enclosing multiple domains, when present) is again generally
ellipsoidal, but this and higher level (quaternary) assemblies are best determined on an individual basis.

\subsubsection{Nucleic acids}

The atomic level representation for DNA and RNA was taken as the phosphate atom
and in the internal scale, the P---P distance is 1 unit.

In double stranded RNA and DNA it is desirable to have base-paired phosphates
move as a linked entity and this was achieved by enclosing them at either end of
a tube.  As well as linking the phosphates, the tube provides a volume to mimic
the bulk of the (unrepresented) nucleotide bases.   The bulk of the bases should
really lie between the midpoints of the P---P virtual bonds and in the refinement the
double helix geometry, which are distinct in RNA and DNA, this difference
was accommodated in the choice of ideal distances and angles.

Segments of base-paired phosphate ladders are again best represented as a tube
which is a good model for the hairpins (stem-loops) found in RNA but to represent an extended
chain of DNA, a succession of segments (like a string of sausages) was used that allowed the
double-helix of the phosphate backbone to progress uninterrupted from one to the next.

\clearpage
\section{Algorithms and Implementation}

\subsection{Collision algorithms}

In the \NAME\ program, the
\TT{bumper} routine has the task of identifying objects that have approached closer
than permitted and repelling them by a fixed-size "kick" specified in the parameter file.
It must overcome two difficulties:  firstly, for large numbers of objects, it is
computationally too expensive to compare all-against-all and, secondly, the objects do not
all have simple shapes so the surface-surface distance between all combinations of
object shapes must be accommodated.

\subsubsection{Avoiding $N \times N$}

The \TT{bumper} routine uses the hierarchic structure of the data to avoid a $N^2$
order calculation between all pairs of objects.  Beginning at the highest level (1)
all objects at that level are compared pairwise but only if two objects at this level
are in collision, are their children then considered. 
As discussed in the Introduction, in computer-graphics terms,
the high-level objects are the bounding-volumes for their children. 

However, before the parents are repelled, a calculation is made of how many collisions
there are between their children.  These two distinct calculations of collisions
within a family and collisions between families are performed by {\tt bumpin()}
and {\tt bumpex()}, respectively.

\paragraph{{\tt \bfseries bumpin()}:\\}

If the number of children in a family is less than 20, {\tt bumpin()}
uses a simple pairwise algorithm (in {\tt getBumps()}) to provide a list of objects that
are potentially in collision.  With more children, then an approximate algorithm
is used that is based on the partially sorted X,Y,Z lists maintained internally in \NAME . (See
source code).  This selection is based on the largest dimension of the object:  the maximum
axis length for an ellipsoid or the larger of the length and diameter of a tube.  The list
is sorted by degree of violation so {\tt bumpin()} will deal with the worst cases first.

{\tt bumpin()} firstly checks the true separation of the two objects ({\tt a,b}) using {\tt touch()}
which returns a negative distance if the objects inter-penetrate. (See further sections
below for details of each type of interaction).   If {\tt a} and {\tt b} are not atoms, then
a count ({\tt m}) is made of how many collisions occur between their children using {\tt bumpex()}.
Two parameters,  $hard$ and $soft$, are specified in the input that set the repulsion step
for each type of object.  If both parameters have been given values,
then the degree of repulsion is calculated based on the number of colliding children, {\tt m},
as:  {\tt boot = f*soft + (1-f)*hard;} where {\tt f = exp(-m*m/100);}.     The resulting value
of {\tt boot} is then used by the utility {\tt part2cells()} to push the objects symmetrically
back towards a distance ({\tt d}) where they are no longer in collision. (See Box 1 for
pseudo code\footnote{
The "pseudo" code in the boxed segments is actually {\tt C++} code but employs a number of macros
as short-hands, most of these are obvious (like {\tt DO} and {\tt FOR}), however the following
less obvious vector operations are used:
"{a$|$b}" = the distance between points {\tt a} and {\tt b},
"{a*b}" = scalar (dot) product,
"{a\^b}" = vector (cross) product and
"{a\&b}" = their mid-point.
The {\tt Cell} data structure represents an object (at any level) and encodes the 
number of children ({\tt kids}) specified in the list: {\tt child[...]}.
A number of utilities operate on each object and most do what they say (eg;
{\tt moveCell()}, {\tt spinCell()}, {\tt part2Cells()}, etc.) and apply the transform
not only to the cell specified in the argument list, but recursively to all that it 
contains.}).

\begin{figure}[h]
\centering
%\begin{singlespace}
\begin{tiny}
\begin{Verbatim}[frame=single]
int Cell::bumpin () {
// the children of the current cell <this> are checked for intra-family bumps
// <level> is the position in the hierarchy of the current object
// <depth> is the atomic (lowest) level
       :
       kidlev = level+1;
       :
       FOR(i,in) { Cell *a = list[i].a, *b = list[i].b;
               bump = touch(a,b); // -ve is bad
               if (bump > -NOISE) continue; // ignore touching objects
               if (kidlev<depth) m = bumpex(a,b); else m = 0;  // bumping a+b children parted in bumpex() 
               if (exempt(a,b)) continue;      // exempt parents (exempt atoms are skipped in getBumpin()) 
               // the pair (a,b) are bumping so repel with a kick using the number of bumping children (m)
               //      unless weight=0 then just use unmodified <soft> value
               if (weight) { // Gaussian switch from soft to hard with increasing <m>
                       d = (float)m; f = exp(-d*d*0.01);
                       boot = f*soft + (1.0-f)*hard;
                       boot *= kick;
               } else { boot = soft; }
               d = (a->xyz|b->xyz)-bump*over; // clash = -ve bump
               part2cells(a,b,d,-boot); // -kick = repel only
               :
       }
}
\end{Verbatim}
\end{tiny}
%\end{singlespace}
\caption*{
Box 1:
\label{Fig:box1}
\begin{footnotesize}
{\bf Code for the {\ttfamily \bfseries bumpin()} routine} which repels colliding children within the current
object ({\tt Cell} structure).  The routine is called recursively over the tree of objects.   When two
children are in collision, their combined children are evaluated for collisions by {\tt bumpex()}
(see below and Box 2) which returns the number of collisions detected between the families.
\end{footnotesize}
}
\end{figure}

Both {\tt bumpin()} and {\tt getBumps()} employ a filter encoded in {\tt exempt()} that is
{\small \tt TRUE} if the two objects are exempt from collisions, for example, if they are bonded or linked.
In  {\tt bumpin()}, however, {\tt exempt()} is only called after  {\tt bumpex()} as the children
(and their offspring) inside two exempt objects might well be in collision.

\paragraph{{\tt \bfseries bumpex()}:\\}

The {\tt bumpex()} routine evaluates each pair of children between their two colliding parents
and returns the number of collisions.  As it does so, it also takes steps to rectify the
situation by separating the clashing children.  As it is known to which parent each child belongs,
they are also given a nudge back towards their parent before being separated. 
The strength of these kicks depend on both the $hard$ and $soft$ parameter values:
the nudge back home is always $soft$/10 while the separation is $hard$ at the atomic level
and $soft$ for higher levels.  (See Box 2).

\begin{figure}[h]
\centering
%\begin{singlespace}
\begin{tiny}
\begin{Verbatim}[frame=single]
int bumpex ( Cell *a, Cell *b ) {
// the children of the cell <a> and <b> are checked for inter-family bumps
float   strength = 0.1;
        :
        kidlev = level+1;
        if (kidlev==depth) kick = hard; else kick = soft;
        axis = b->xyz - a->xyz;
        axis.setVec(soft);        // <soft> length vector from a to b (NB has to be set at atom level)
        :
        FOR(i,a->kids) { Cell* ai = a->child[i];
                FOR(j,b->kids) { Cell* bj = b->child[j];
                        if (exempt(ai,bj)) continue;
                        bump = touch(ai,bj);
                        if (bump > -NOISE) continue; // ignore touching objects
                        d = (ai->xyz|bj->xyz)-bump*over; // d = target gap (NB clash has -ve bump)
                        moveCell(ai,axis,-1);        // nudge ai towards a
                        moveCell(bj,axis, 1);        // nudge bj towards b
                        part2cells(ai,bj,d,-kick*strength); // -kick = repel only
                        :
                        bumpex(ai,bj);
                        n++;
                }
        }
        return n;
}
\end{Verbatim}
\end{tiny}
%\end{singlespace}
\caption*{
Box 2:
\label{Fig:box2}
\begin{footnotesize}
{\bf Code for the {\ttfamily \bfseries bumpex()} routine} which repels colliding children between two objects ({\tt Cell}s).
The routine is called from {\tt bumpin()} and acts recursively on pairs of colliding children and their children.
\end{footnotesize}
}
\end{figure}

Once {{\tt bumpin()} has completed at one level, it is called recursively and continues to traverse 
the hierarchic tree of objects in a depth-first order.
The application of the {{\tt bumpin()}/{{\tt bumpex()} pair of routines is not recursive: ie:
{{\tt bumpex()} does not re-call {{\tt bumpin()} on colliding children.  However, {\tt bumpex()}
is itself recursive and is called on the children of any clashing children that it encounters. 

\subsubsection{Calculating contacts}

\NAME\ employes three object types, giving six possible types of encounter
which are dealt with by the {\tt touch()} routine (Box 3).

\begin{figure}[h]
\centering
%\begin{singlespace}
\begin{tiny}
\begin{Verbatim}[frame=single]
float touch ( Cell *a, Cell *b )
{ // closest approach between two object surfaces
  // +ve = separation, -ve = penetration depth
       :
       rab = ra + rb;  // average of bump radii
       tab = ta * tb;  // product of object types
       if (tab>1) s = Seg(b->endN,b->endC);
       switch (tab) {
               case 1: // spheres = centre distance
                       return (pa|pb)-rab;
               case 2: // sphere+tube (closest approach to line segment or ends)
                       if (pa.vec_in_seg(s)) return pa.vec_to_line(s)-rab;
                       return fmin(pa|s.A,pa|s.B) - rab;
               case 3: // sphere+ellipsoid (in keeper.cpp)
                       return vec_to_egg(pa,s,db) - ra;
               case 4: // tubes = closest approach of 2 line segments
                       return seg_to_seg(Seg(a->endN,a->endC),Seg(b->endN,b->endC))-rab;
               case 6: // tube+ellipsoid (in bumper.cpp)
                       return tube_to_egg(a,b);
               case 9: // ellipsoid (in bumper.cpp)
                       return egg_to_egg(a,b);
       }
}
\end{Verbatim}
\end{tiny}
%\end{singlespace}
\caption*{
Box 3:
\label{Fig:box3}
\begin{footnotesize}
{\bf Code for the {\ttfamily \bfseries touch()} routine} which returns the distance between the surfaces of two objects.
Each combination of the three object types: sphere, tube, ellipsoid (coded 1,2,3), are treated separately.
\end{footnotesize}
}
\end{figure}

\paragraph{Sphere/Sphere:\\}

A pair of spheres are the simplest case, with surface contact made at the average distance of their bumping diameters.
(Or the sum of the corresponding radii: $R_{ab} = R_a + R_b$, for two objects $a$ and $b$).

\paragraph{Sphere/Tube:\\}

For a sphere and a tube, the closest approach is the shortest sphere-centre to tube axis 
line-segment, less their joint radii ($R_{ab}$).   If a perpendicular construction from the 
sphere centre to the axis line lies within the tube end-points then this, less $R_{ab}$,
is the closest approach of their surfaces.  Otherwise, it is simply the shorter tube-end to
sphere distance (less $R_{ab}$).

\paragraph{Sphere/Ellipsoid:\\}

The distance of a point from the surface of a general (scalene) ellipsoid in not trivial,
however, as \NAME\ only deals with spheroids, a simple construction based on the foci of
their ellipse-of-rotation can be used to decide if a point is inside or outside the ellipsoid.
A path from one focus to any point on the ellipse and back to the other focus, has a constant
length.  (A property often exploited to draw an ellipse with a fixed length of string).
The distance of the foci from the centre can be solved from the lengths of the axes, A and B,
as: $c = \surd(a^2-b^2)$, where $a$ and $b$ are the semi-axis lengths.  (See construction and details in Box 4).
So if the summed distance from any point to the foci is longer than the 'string' length, it is outside
and, if less, it is inside.

\begin{figure}[h]
\centering
\epsfxsize=300pt \epsfbox{figs/geom/ellipse.eps}
\caption*{
Box 4:
\label{Fig:box4}
\begin{footnotesize}
{\bf Construct for the {\ttfamily \bfseries inEgg()} routine} which determines if a sphere and an ellipsoid make contact.  
The point {\tt o} is the centre of a sphere lying outside an ellipsoid with major axis
length {\tt a} and minor axis length {\tt b}.  The ellipse (blue) lies in the plane of the ellipsoid axis of rotational
symmetry and the point {\tt o}, with foci are marked as {\tt f1} and {\tt f2}.   If {\tt d} is the distance from a
focus to the minor axis end-point, and {\tt c} is the focus to centre distance, then the length of a focus1-surface-focus2 
path along the major axis is {\tt c+a+(a-c)} = 2{\tt a} and at the minor axis is 2{\tt d}.  Since the paths are equal: {\tt d} = {\tt a};
so {\tt c}$^2$ =  {\tt d}$^2$-{\tt b}$^2$ = {\tt a}$^2$-{\tt b}$^2$ and {\tt c} = {\tt sqrt(a$^2$-b$^2$)}.  Knowing {\tt c},
the path to {\bf o} (dashed) can be found and if this is less than 2{\tt a}, the point lies inside, otherwise out.  However,
we want the surface of the sphere not its centre, but the locus of the centre of a sphere (with radius {\tt r}) in contact with an
ellipsoid is also an ellipsoid, so modifying the semi-axis lengths to {\tt a}+{\tt r} and {\tt b}+{\tt r} gives the required result.
\end{footnotesize}
}
\end{figure}

The sum of the foci distances less the 'string' length is zero on the surface but elsewhere is not
the true distance to the surface.  However, when scaled by 1.4, this value is a good approximation
to the true distance to the surface for both prolate and oblate ellipsoids and is the value returned
by the routine {\tt inEgg()}, which encodes this algorithm.   In its most minimal form, the algorithm
only needs to calculate two distances but as the foci positions are not stored these are also calculated.

In the range $0\ldots R_{ab}$ a more complicated but accurate routine {\tt vec\_to\_egg()} is
used to return the true value of the distance between the surfaces.

\paragraph{Tube/Tube:\\}

If a mutual perpendicular line (the contact normal) is constructed between the axes of a pair
of tubes and if the ends of this lie between the end-points of the tubes, then this is the
closest approach.   Otherwise one of the four end-end distances will be shortest.   The shortest
distance, less $R_{ab}$ is the distance between the surfaces.

\paragraph{Tube/Ellipsoid:\\}

The distance of a tube to an ellipsoid is found using the same algorithm described above
for a point (sphere) and ellipsoid ({\tt inEgg()}) by iteratively bisecting the line between the
tube end-points.

Starting with the three end---mid---end points along the axis ($p1,p2,p3$), then if any corresponding
distance ($d1,d2,d3$) returned by {\tt inEgg()} is negative, there is a clash.   Otherwise, the point
associated with the largest value can be excluded and the calculation repeated with the remaining
two points and their midpoint. (Box 5)   The algorithm converges rapidly and is stopped when the points
get too close.   At the end, the true distance to the ellipsoid surface is returned using the more
complicated {\tt vec\_to\_egg()} routine (since the {\tt inEgg()} value is only exact at the surface).

\begin{figure}[h]
\centering
%\begin{singlespace}
\begin{tiny}
\begin{Verbatim}[frame=single]
float tube_to_egg ( Cell *a, Cell *b ) {
// returns an approximation to the closest approach of a tube <a> to an ellipsoid <b> surface
// NB the value returned by inEgg() is not a surface distance but is zero on the surface
// NB assumes radially symmetric ellipsoid
       :
       p1 = a->endN; p2 = a->xyz; p3 = a->endC;
       DO { float d;
               d1 = inEgg(p1,cb,sizeb);
               d2 = inEgg(p2,cb,sizeb);
               d3 = inEgg(p3,cb,sizeb);
               if (d1<0 || d2<0 || d3<0) return -999.9; // flag bump;
               d = p1|p3;
               if (d < 0.01) { // pretty close
                       d = vec_to_egg(p2,cb,sizeb);
                       return d - sizea*0.5;
               }
               if (d1+d2 < d2+d3) {
                       p3 = p2; p2 = p1 & p2;
               } else {
                       p1 = p2; p2 = p3 & p2;
               }
       }
}
\end{Verbatim}
\end{tiny}
%\end{singlespace}
\caption*{
Box 5:
\label{Fig:box5}
\begin{footnotesize}
{\bf Code for the {\ttfamily \bfseries tube\_to\_egg} routine} that determines if a tube and an ellipsoid make contact.  
The method uses the fast {\tt inEgg()} routine (Box 4) to check for contact and if none is found, returns the separating
distance using the {\tt vec\_to\_egg()} routine which is based on the algorithm described at:
{\tt http://www.iquilezles.org/www/articles/ellipsedist/ellipsedist.htm}.
\end{footnotesize}
}
\end{figure}

\paragraph{Ellipsoid/Ellipsoid:\\}

Surprisingly, there is no analytic solution for the contact normal between two ellipsoid
surfaces as the expression for this is a quartic equation that requires a numerical solution.
A solution probably could be found for the more symmetric case of two spheroids but
instead, a fast iterative algorithm was used to find the contact normal using a recursive
division approach that is an extension of that used for the simpler tube/ellipsoid problem. 

Rather than iteratively bisect a line, as was done on the tube axis, extending the approach
to a surface leads to the iterative subsection of a triangle --- or rather two, as there
are two ellipsoids to consider.   If the triangles are trisected using a mid-point/vertex
construction, the sub-triangles become progressively elongated.  To avoid this, an internal
triangle was constructed from the mid-points of each edge --- so strictly, each triangle is
quad-sected. (See Box 6).

\begin{figure}[h]
\centering
\epsfxsize=410pt \epsfbox{figs/geom/ellipsoid.eps}
\caption*{
Box 6:
\label{Fig:box6}
\begin{footnotesize}
{\bf Construct for the {\ttfamily \bfseries egg\_to\_egg()} routine} that determines if two ellipsoid make contact.  
The progressively smaller inscribed triangles do not lie on the same plane but on the surface of the ellipsoid
as calculated by the {\tt shell()} routine described in Box 7.   The first division generates four triangles
(bold black lines) and separation of their mid-points, projected on the surface (black dots) is measured between
the two ellipsoids.   The triangles associated with the closest pair are then sub-divided in a similar way
(fine lines) and by the third of fourth division, the midpoints lie close to the contact normal between the
two surfaces (green line).
\end{footnotesize}
}
\end{figure}

A starting set of triangles was obtained from the end-points 
of the axes, giving 8 triangles per ellipsoid and a starting pair was selected which had the
shortest mid/mid point distance.  In all the iterations, the mid point is not simply the mean
of the vertices but is the point where the extension of a line from the centre through this point
cuts the ellipsoid surface.  The utility routine {\tt sholl()} that calculates this is given
in Box 7 and is called by the wrapper routine {\tt shell()} that identifies the ellipsoid type
and reconfigures the argument list appropriately.

\begin{figure}[h]
\centering
%\begin{singlespace}
\begin{tiny}
\begin{Verbatim}[frame=single]
Vec sholl ( Vec line, Vec cent, float A, float B, Vec axis ) {
// returns the point on the ellipsoid (<axes> = A>B=C at 0) surface cut by a <line> from the <cent>re
Vec    surf;
float  AA=A*A, BB=B*B, aa,bb,b, d,ff,gg,hh;
/*
in the plane of the major axis (A) and the <line> with components a,b to A,
the point where the line cuts the surface has corresponding components g,h.
Now    gg/AA + hh/BB = 1
and    g/a = h/b
so     gg = AA(1-hh/BB) = aa.hh/bb
       AA - hh.AA/BB = hh.aa/bb
       AA = hh.aa/bb + hh.AA/BB
       hh = AA/(aa/bb+AA/BB)
*/
       line -= cent;                                   // shift line to origin
       b = line.vec_to_line(axis);                     // perpendicular dist from line to axis
       bb = b*b;
       ff = line.sqr();
       aa = ff-bb;
       hh = AA/(aa/bb+AA/BB);
       gg = aa*hh/bb;
       d = sqrt((gg+hh)/ff);
       surf = line*d;                                  // extend <line> to ellipsoid surface
       return cent+surf;                               // added back to centre
}
\end{Verbatim}
\end{tiny}
%\end{singlespace}
\caption*{
Box 7:
\label{Fig:box3}
\begin{footnotesize}
{\bf Code for the {\ttfamily \bfseries sholl()} routine} which returns the point at which a line from the
centre cuts the ellipsoid surface.  This routine is specific for a prolate ellipsoid but is called inside 
a wrapper called {\tt shell()} that reconfigures the parameters to deal with any ellipsoid.
\end{footnotesize}
}
\end{figure}

As the selection of the two starting quadrants is based on a rough estimate, all 64 distances are ranked
and the top three combinations taken as separate starting pairs.   The routine then iterates down to the
best pair of (sub-)$_n$triangles in each (max $n=3$) and takes the solution with the shortest separation.
As a final refinement, nine points are selected around each mid-point and the closest pair taken.  
This solution is then checked using {\tt vec\_to\_egg()} to find the distance from the best pair to the
opposing ellipsoid.  These should be identical if the true contact normal has been found.
The error is typically less than 0.1\%.

%--------------------------------------------------
%\begin{figure}[h]
%\centering
%\begin{singlespace}
%\begin{tiny}
%\begin{Verbatim}[frame=single]
%Vec sholl ( Vec line, Vec cent, float A, float B, Vec axis ) {
%// returns the point on the ellipsoid (<axes> = A>B=C at 0) surface cut by a <line> from the <cent>re
%Vec    surf;
%       return cent+surf;                               // added back to centre
%}
%\end{Verbatim}
%\end{tiny}
%\end{singlespace}
%\caption*{
%Box 7:
%\label{Fig:box3}
%\begin{footnotesize}
%{\bf Code for the {\ttfamily \bfseries sholl()} routine} which returns the point at which a line from the
%\end{footnotesize}
%}
%\end{figure}
%--------------------------------------------------
%from cell.cpp
%
%float inEgg ( Vec, Vec, Vec, float );
%
%// short temp names for Data::globals
%char  *names;
%int   *shape, *links, *chain, *split, *local, *align;
%float *sizes, *bumps, *kicks, *keeps, *bonds, *repel, *rejel;
%// common temp variables
%int   total, depth, model, moltype, subtype;
%
%///////// bumper
%
%float touch ( Cell *a, Cell *b )
%{ // closest approach between two cell bump surfaces (of the same shape type)
%  // +ve = separation, -ve = penetration depth
%float	ra, rb, da, db, d, rab;
%int	ta, tb, tab;
%Vec	pa, pb;
%Seg	s;
%	if (a->type > b->type) { Cell *c = a; a = b; b = c; } // swap
%	ta = a->type; tb = b->type;
%	da = Data::model[a->model].bumps[a->level]; ra = da*0.5;
%	db = Data::model[b->model].bumps[b->level]; rb = db*0.5;
%	pa = a->xyz; pb = b->xyz;
%	rab = ra + rb;
%	tab = ta * tb;
%	if (tab>1) s = Seg(b->endN,b->endC);
%	switch (tab) { // smallest type cell first
%		case 0:	// virtual spheres don't bump?
%			return (pa|pb)-rab; // 9999.9;
%		case 1:	// spheres = centre distance
%			return (pa|pb)-rab;
%		case 2:	// sphere+tube (closest approach to line segment or ends)
%			if (pa.vec_in_seg(s)) return pa.vec_to_line(s)-rab;
%			return fmin(pa|s.A,pa|s.B) - rab;
%		case 3:	// sphere+ellipsoid (in keeper.cpp)
%			return vec_to_egg(pa,s,db) - ra;
%		case 4:	// tubes = closest approach of 2 line segments
%			return seg_to_seg(Seg(a->endN,a->endC),Seg(b->endN,b->endC))-rab;
%		case 6:	// tube+ellipsoid (in bumper.cpp)
%			return tube_to_egg(a,b);
%		case 9: // ellipsoid (in bumper.cpp)
%			return egg_to_egg(a,b);
%	}
%}
%
%int bumpex ( Cell *a, Cell *b ) {
%// the children of the cell <a> and <b> are checked for inter-family bumps
%int	i, j, level = a->level, kidlev, n = 0;
%float	d, bumpa,bumpb, bump, over = 1.101;
%float	kicka, kickb, hard, soft, kick;
%float	strength = 0.1;
%Vec	axis;
%	if (a->solid > 0 || b->solid > 0 ) return 0;
%	if (a->empty > 0 || b->empty > 0 ) return 0;
%	if (a->kids == 0 || b->kids == 0 ) return 0;	// no children to bump
%	if (a->level != b->level) return 0; // different level
%	kidlev = level+1;
%	kicka = Data::model[a->model].repel[kidlev],
%	kickb = Data::model[b->model].repel[kidlev],
%	hard = 0.5*(kicka+kickb);
%	kicka = Data::model[a->model].rejel[kidlev],
%	kickb = Data::model[b->model].rejel[kidlev],
%	soft = 0.5*(kicka+kickb);
%	if (kidlev==Data::depth) kick = hard; else kick = soft;
%	axis = b->xyz - a->xyz;
%	axis.setVec(soft);	// soft length vector from a to b (NB has to be set at atom level)
%	FOR(i,a->kids) { Cell* ai = a->child[i];
%		if (ai->empty) continue;
%		FOR(j,b->kids) { Cell* bj = b->child[j];
%			if (bj->empty) continue;
%			if (exempt(ai,bj)) continue;
%			bump = touch(ai,bj);
%			if (bump > -NOISE) continue;
%			d = (ai->xyz|bj->xyz)-bump*over; // d = target gap (NB clash has -ve bump)
%			moveCell(ai,axis,-1);	// nudge ai towards a
%			moveCell(bj,axis, 1);	// nudge bj towards b
%			part2cells(ai,bj,d,-kick*strength); // -kick = repel only
%                        ai->bump = LIVE; bj->bump = LIVE;
%                        ai->hit = bj; bj->hit = ai;
%			n++;
%		}
%	}
%	return n;
%}
%
%int Cell::bumpin () {
%// the children of the current cell <this> are checked for intra-family bumps
%Bumps	*list;
%int	i, j, kidlev, in, m, n = 0;
%float	d, bump, boot, kick, over = 1.01;
%float	hard, soft;
%int	weight = 0;
%	if (this->bump > 0) { // count-down refractory period and if over, clear hit
%	// the plan is to use the period of bumping to activate MD/refinement in potter() 
%		this->bump--;
%		if (this->bump==0) this->hit = 0;
%	}
%	if (solid > 0 ) return 0;
%	if (empty > 0 ) return 0;
%	if (kids == 0 ) return 0;	// no children to bump
%	list = new Bumps[HOLD*kids];
%	kidlev = level+1;
%	hard = Data::model[model].repel[kidlev]; // hard (for hard-shell bump)
%	soft = Data::model[model].rejel[kidlev]; // soft (for jelly bumping)
%	depth = Data::depth;
%	if (kidlev==depth) {
%		kick = hard; // atomic level has hard-shell bump
%	} else {
%		kick = soft; // higher levels have jelly bumping modified by kids if...
%		if (kick > NOISE) weight = 1; // +ve = weight kick by kids (as Gauss(m) soft<-->hard)
%	}
%	if (kick < 0.0) kick = -kick;
%	in = getBumpin(this,list); // list of bumping pairs (by NxN or sort for big N) 
%	for (i=0; i<in; i++) { Cell *a = list[i].a, *b = list[i].b;
%		bump = touch(a,b);
%		if (bump > -NOISE) continue;
%		if (kidlev<depth) m = bumpex(a,b); else m = 0;	// bumping a+b children parted in bumpex() 
%		if (exempt(a,b)) continue;	// exempt parents (exempt atoms skipped in getBumpin()) 
%		// the pair (a,b) are bumping so repel more with more bumping children (m)
%		//	unless weight=0 then just use unmodified <soft> value
%		if (weight) { // Gaussian switch from soft to hard with increasing <m>
%			d = (float)m; d = exp(-d*d);
%			boot = d*soft + (1.0-d)*hard;
%			boot *= kick;
%		} else { boot = kick; }
%		d = (a->xyz|b->xyz)-bump*over; // clash = -ve bump
%		part2cells(a,b,d,-boot); // -kick = repe/l only
%		if (kidlev<depth) {
%               		a->bump = LIVE; b->bump = LIVE;
%                        // a->hit = b; b->hit = a; // replace current interaction? trapped in exempt()?
%               		if (!a->hit) a->hit = b;
%			if (!b->hit) b->hit = a;
%		}
%		n++;
%	}
%	delete [] list;
%}
%
%void Cell::bumps () {
%	this->bumpin();
%	for (int i=0; i<kids; i++) child[i]->bumps();
%}
%
%
%--------------------------------------------------
%from bumper.cpp
%
%
%#include "util.hpp"
%#include "geom.hpp"
%#include "cell.hpp"
%#include "data.hpp"
%
%float inEgg ( Vec, Seg, float );
%
%void bumper ()
%{
%	Cell::world->bumps();
%}
%
%bool exempt ( Cell *a, Cell *b )
%{ // returns 1 if <a> and <b> are exempt from bumping
%//if (a->hit) { Pi(a->level) Pi(a->id) Pi(a->bump) NL }
%	if (a->hit && a->hit==b) return 1;
%	if (b->hit && b->hit==a) return 1;
%	FOR(k,a->nbonds) { if (a->bond[k].to==b) return 1; }
%	FOR(k,b->nbonds) { if (b->bond[k].to==a) return 1; }
%	FOR(k,a->nlinks) { if (a->link[k].to==b) return 1; }
%	FOR(k,b->nlinks) { if (b->link[k].to==a) return 1; }
%	return 0;
%}
%
%#define SWITCH 20	// number of cells below which bump testing is pairwise
%
%int sortBumps ( const void *ac, const void *bc )
%{
%        Bumps   *a = (Bumps*)ac, *b = (Bumps*)bc;
%        if (a->d < b->d) return -1;
%        if (a->d > b->d) return  1;
%        return 0;
%}
%
%int getBumpin ( Cell *cell, Bumps *pairs ) {
%// return the number (and <list>) of possible bumping pairs in cell <c> closer than <bump>
%// <bump>: spheres=rad.s, tubes=lengths, ellipsoids=max-axes
%Cell	*a, *b;
%float	d, dd, bump, bbump;
%Cell	*kid = cell->child[0];
%Data    *p = Data::model+kid->model;
%int	kidlev = kid->level;
%float	size = p->bumps[kidlev];
%int	type = cell->type,
%	kids = cell->kids,
%	hold = HOLD*kids,
%	i, j, k, m, n=0;
%int	*close = new int[hold];
%	if (kids==1) return 0;
%	if (kids < SWITCH) {	// use pairwise
%		for (i=0; i<kids-1; i++) {
%			a = cell->child[i];
%			if (a->empty) continue;
%			for (j=i+1; j<kids; j++) {
%				b = cell->child[j];
%				if (b->empty) continue;
%				if (kidlev==Data::depth && exempt(a,b)) continue; // just filter atom level
%				if (a->len > size) bump = a->len; else bump = size;
%				if (b->len > size) bump += b->len; else bump += size;
%				bump *= 0.5; bbump = bump*bump;
%				dd = a->xyz||b->xyz;
%				if (dd > bbump) continue;
%				pairs[n].c = 0; // not used
%				pairs[n].a = a; pairs[n].b = b;
%				pairs[n].d = sqrt(dd);
%				pairs[n].bump = bump;
%				n++;
%				if (n == hold) break;
%			}
%			if (n == hold) break;
%		}
%		if (n==0) return 0;
%		qsort(pairs,n,sizeof(Bumps),sortBumps);         // sort on separation (closest first)
%		return n;
%	} else	// use sorted lists to find pairs
%	{ int   got, span = 5+(int)sqrt((float)kids);
%		for (i=0; i<kids; i++) {
%			a = cell->child[i];
%			if (a->empty) continue;
%			m = 0;
%			for (j=0; j<3; j++) // gather locally ranked children in each dimension
%			{ int	rat = a->ranks[j], out;
%				out = 0;
%				for (k=rat-span; k<rat+span; k++) { // check the local rank list
%					if (k>=kids) break;	// intra-family so max=kids
%					if (k<0) continue;	// not on list yet
%					if (k==rat) continue;	// skip self
%					if (n == hold) break;
%					b  = cell->rank[k][j];
%					if (b->empty) continue;
%					if (kidlev==Data::depth && exempt(a,b)) continue; // filter atom level
%					close[m] = 10*(b->uid) + j + 1;	// code dim as j/10
%					m++;
%					if (m==hold) break;
%				}
%				if (m==hold) break;
%			}
%			sort(close,m);
%			got = 1; // 123 = XYZ (in sorted order in pairs)
%			FOR(ii,m) { int hit, dim;  // keep only children present in all 3 dimensions
%				hit = (int)(0.1*(float)close[ii]);
%				dim = close[ii]-hit*10;
%				if (dim != got) continue;
%				if (got==3) { float d; // keep
%					got = 0;
%					b = Cell::uid2cell[hit];
%					if (a->len > size) bump = a->len; else bump = size;
%					if (b->len > size) bump += b->len; else bump += size;
%					bump *= 0.5; bbump = bump*bump;
%					dd = a->xyz||b->xyz;
%					if (dd < bbump) {
%						pairs[n].c = 0; // not used
%						pairs[n].a = a; pairs[n].b = b;
%						pairs[n].d = sqrt(dd);
%						pairs[n].bump = bump;
%						n++;
%					}
%					if (n==hold) break;
%				}
%				if (n==hold) break;
%				got++;
%			}
%		}
%		if (n==0) return 0;
%		qsort(pairs,n,sizeof(Bumps),sortBumps);         // sort on separation (closest first)
%		m = 1;
%		FOR(ii,n) { // remove duplicate entries
%			if (ii==0) continue;
%			if ((pairs[ii].a->uid==pairs[ii-1].a->uid) && (pairs[ii].b->uid==pairs[ii-1].b->uid)) continue;
%			if ((pairs[ii].a->uid==pairs[ii-1].b->uid) && (pairs[ii].b->uid==pairs[ii-1].a->uid)) continue;
%			pairs[m] = pairs[ii];
%			m++;
%		}
%		return m;
%	}
%}
%
%float tube_to_egg ( Cell *a, Cell *b ) {
%// returns an approximation to the closest approach of a tube <a> to an ellipsoid <b> surface
%// NB the value returned by inEgg() is not a surface distance but is zero on the surface
%// NB assumes radially symmetric ellipsoid
%Seg	ca = Seg(a->endN,a->endC),	cb = Seg(b->endN,b->endC);
%Data	*pa = Data::model+a->model,	*pb = Data::model+b->model;
%float	sizea = pa->sizes[a->level],	sizeb = pb->sizes[b->level];
%float	d1,d2,d3;
%Vec	p1,p2,p3;
%	if (a->type!=2 && b->type!=3) { Pt(Bad types in tube_to_egg()) Pi(a->type) Pi(b->type) NL exit(1); }
%	p1 = a->endN; p2 = a->xyz; p3 = a->endC;
%	LOOP { float d;
%		d1 = inEgg(p1,cb,sizeb);
%		d2 = inEgg(p2,cb,sizeb);
%		d3 = inEgg(p3,cb,sizeb);
%		if (d1<0 || d2<0 || d3<0) return -999.9; // flag bump;
%		d = p1|p3;
%		if (d < 0.01) { // pretty close
%			d = vec_to_egg(p2,cb,sizeb);
%			return d - sizea*0.5;
%		}
%		if (d1+d2 < d2+d3) {
%			p3 = p2; p2 = p1 & p2;
%		} else {
%			p1 = p2; p2 = p3 & p2;
%		}
%	}
%}
%
%// tested in newsims/bumpell
%#define Nrand  10 // 20 // WAS 500 for testing
%#define Nhold 500
%
%Seg trisect ( int, Vec*, Vec*, Vec*, Vec*, Vec, Vec, Mat, Mat, Vec, Vec, Vec, Vec, float, int );
%Vec shell ( Vec, Vec, Vec, Mat, Vec );
%Vec shall ( Vec, Vec, Vec, Mat, Vec );
%Vec sholl ( Vec, Vec, float, float, Vec );
%float bumping ( int, Vec*, Vec*, Vec, Vec, Vec, Vec, Mat, Mat );
%float in_egg ( Vec, Vec, Vec, Mat );
%
%float egg_to_egg ( Cell *a, Cell *b ) {
%// returns a good approximation to the closest approach of two (general) ellipsoid surfaces
%Data	*pa = Data::model+a->model,	*pb = Data::model+b->model;
%float	sizea = pa->sizes[a->level],	sizeb = pb->sizes[b->level],	// A=B diameter
%	denda = a->endN|a->endC,	dendb = b->endN|b->endC,	// C axis length
%	dmina,dminb, dmaxa,dmaxb, dmin,dmax, da,db, d;
%Seg	ca = Seg(a->endN,a->endC), cb = Seg(b->endN,b->endC), c, p;
%Seg	ends, best;
%float	dends, wsum;
%float	**mat, score, rand = 0.2; // WAS 0.5 for testing
%Mat	axesA, axesB;
%Vec	axisA, axisB, centA, centB, bestA, bestB, surfA, surfB;
%Vec	quad[8], quadA[8], quadB[8], sectA[6], sectB[6];
%Vec	dispA[Nrand], dispB[Nrand];
%Vec	mid, ave, aimA, aimB;
%Vec	moveA, moveB;
%Pairs	dist[64];
%int	rank[64];
%int	qA,qB, qAtop,qBtop, n = 0;
%Vec	allA[Nhold], allB[Nhold];
%Vec	randout;
%int	on = 0;
%	if (a->ends < 0) sizea = denda/Data::Eratio[a->sort]; // use given ratio and C length
%	if (b->ends < 0) sizeb = dendb/Data::Eratio[b->sort]; // use given ratio and C length
%	dmina = min(sizea,denda);	dminb = min(sizeb,dendb);
%	dmaxa = max(sizea,denda);	dmaxb = max(sizeb,dendb);
%	dmin = (dmina+dminb)*0.5;	dmax = (dmaxa+dmaxb)*0.5;
%	d = a->xyz|b->xyz;
%	if (d > dmax) return 999.9;	// beyond maximum contact distance
%	if (d < dmin) return d-dmin;	// centres closer than minimum separation
%	sizea *= 0.5; sizeb *= 0.5; denda *= 0.5; dendb *= 0.5;	// reset to semiaxis lengths
%	mat = new float*[6]; FOR(i,6) mat[i] = new float[6];
%	centA = a->xyz; centB = b->xyz;
%	mid = (centA+centB)*0.5;
%	axisA.x = denda;  axisA.y = axisA.z = sizea;
%	axisB.x = dendb;  axisB.y = axisB.z = sizeb;
%	axesA.A = a->endC - a->xyz;
%	randout = (axesA.A^centB).norm();
%	axesA.B = (axesA.A^randout).getVec(sizea);
%	axesA.C = (axesA.A^axesA.B).getVec(sizea);
%	axesB.A = b->endC - b->xyz;
%	axesB.B = (axesB.A^randout).getVec(sizeb);
%	axesB.C = (axesB.A^axesB.B).getVec(sizeb);
%	quad[0] =  Vec( 1, 1, 1); quad[1] =  Vec( 1, 1,-1); 
%	quad[2] =  Vec( 1,-1, 1); quad[3] =  Vec( 1,-1,-1);
%	quad[4] =  Vec(-1, 1, 1); quad[5] =  Vec(-1, 1,-1);
%	quad[6] =  Vec(-1,-1, 1); quad[7] =  Vec(-1,-1,-1);
%	FOR(i,8) // make real axis end-points for both ellipsoids and put surface centroids in quad[AB]
%	{ Vec	midA, midB;
%		midA = centA + (axesA.A*quad[i].x + axesA.B*quad[i].y + axesA.C*quad[i].z)/3.0;
%		allA[i] = quadA[i] =  shell(midA,centA,axisA,axesA,quad[i]);
%		midB = centB + (axesB.A*quad[i].x + axesB.B*quad[i].y + axesB.C*quad[i].z)/3.0;
%		allB[i] = quadB[i] =  shell(midB,centB,axisB,axesB,quad[i]);
%	}
%	sectA[0] = centA+axesA.A; sectB[0] = centB+axesB.A;
%	sectA[1] = centA+axesA.B; sectB[1] = centB+axesB.B;
%	sectA[2] = centA+axesA.C; sectB[2] = centB+axesB.C;
%	sectA[3] = centA-axesA.A; sectB[3] = centB-axesB.A;
%	sectA[4] = centA-axesA.B; sectB[4] = centB-axesB.B;
%	sectA[5] = centA-axesA.C; sectB[5] = centB-axesB.C;
%	FOR(i,6) { allA[i+8] = sectA[i]; allB[i+8] = sectB[i]; }
%	d = bumping(14, allA,allB, centA,centB, axisA,axisB, axesA,axesB);
%	if (d>NOISE) return -d;
%	n = 0;
%	dends = 9999.9;
%	wsum = 0.0;
%	ave.zero();
%	d = centA | centB;
%	FOR(i,14) FOR(j,14)
%	{ float w, dij; Vec aij; Vec pAi = allA[i], pBj = allB[j];
%		dij = pAi|pBj;  aij = pAi+pBj;
%		if (dij > d) continue;
%		if (dij < dends) { dends = dij; best.A = pAi; best.B = pBj; }
%		w = 1.0/(dij*dij); wsum += w;
%		ave += aij*0.5*w;
%		n++;
%	}
%	ave /= wsum;
%	aimA = shell(ave,centA,axisA,axesA,quad[0]);
%	aimB = shell(ave,centB,axisB,axesB,quad[0]);
%	n = 0;
%	FOR(i,8) FOR(j,8) {
%		dist[n].a = i; dist[n].b = j; 
%		dist[n].s = (quadA[i]|quadB[j])+(aimA|quadA[i])+(aimB|quadB[j]);
%		n++;
%	}
%	sort(dist,rank,-n);
%	dmin = 999.9;
%	allA[6] = aimA; allB[6] = aimB;
%	FOR(i,3) // test just the top 3
%	{ int	r = rank[i], qA = dist[r].a, qB = dist[r].b;
%	  float dab;
%		// pass quadrant end-points and mid-points in sect[AB] to trisect()
%		sectA[0] = centA + axesA.A*quad[qA].x;
%		sectA[2] = centA + axesA.B*quad[qA].y;
%		sectA[4] = centA + axesA.C*quad[qA].z;
%		sectA[1] = shell((sectA[0]+sectA[2])*0.5,centA,axisA,axesA,quad[qA]);
%		sectA[3] = shell((sectA[2]+sectA[4])*0.5,centA,axisA,axesA,quad[qA]);
%		sectA[5] = shell((sectA[4]+sectA[0])*0.5,centA,axisA,axesA,quad[qA]);
%		sectB[0] = centB + axesB.A*quad[qB].x;
%		sectB[2] = centB + axesB.B*quad[qB].y;
%		sectB[4] = centB + axesB.C*quad[qB].z;
%		sectB[1] = shell((sectB[0]+sectB[2])*0.5,centB,axisB,axesB,quad[qB]);
%		sectB[3] = shell((sectB[2]+sectB[4])*0.5,centB,axisB,axesB,quad[qB]);
%		sectB[5] = shell((sectB[4]+sectB[0])*0.5,centB,axisB,axesB,quad[qB]);
%		FOR(j,6) { allA[j] = sectA[j]; allB[j] = sectB[j]; }
%		ends = trisect(7,allA,allB,sectA,sectB,centA,centB,axesA,axesB,axisA,axisB,quad[qA],quad[qB],9999.9,0);
%		if (ends.B.z > 9999.0) return -ends.B.x;	// found bumping
%		dab = ends.len();
%		if (dab > dmin) continue;
%		best = ends; dmin = dab; qAtop = qA; qBtop = qB; n = i;
%	}
%	rand *= sqrt(dmin);
%	moveA = best.A;
%	FOR(i,Nrand) { Vec v = moveA; v.set_disp(rand);
%		surfA = shell(v,centA,axisA,axesA,quad[qAtop]);
%		dispA[i] = surfA;
%		d = surfA|best.B; if (d<dmin) { moveA = surfA; dmin = d; }
%	}
%	moveB = best.B;
%	FOR(i,Nrand) { Vec v = moveB; v.set_disp(rand);
%		surfB = shell(v,centB,axisB,axesB,quad[qBtop]);
%		dispB[i] = surfB;
%		d = surfB|moveA; if (d<dmin) { moveB = surfB; dmin = d; }
%	}
%	FOR(i,Nrand) FOR(j,Nrand) {
%		d = dispA[i]|dispB[j];
%		if (d<dmin) {
%			moveA = dispA[i]; moveB = dispB[j]; dmin = d;
%		}
%	}
%	return dmin;
%}
%
%float check_normal ( Vec A, Vec a0, Vec a1, Vec a2,  Vec B, Vec b0, Vec b1, Vec b2 ) {
%// return the sum of the distances that the normals from <A> and <B> pass their opposing points
%Vec	normA, normB;
%float	toA, toB;
%	normA = A+((a1-a0)^(a2-a0));
%	normB = B+((b1-b0)^(b2-b0));
%	toA = A.vec_to_line(B,normB);
%	toB = B.vec_to_line(A,normA);
%	return toA+toB;
%}
%
%Seg trisect ( int on, Vec *allA, Vec *allB, Vec *sectA, Vec *sectB, Vec centA, Vec centB, Mat axesA, Mat axesB, Vec axisA, Vec axisB, Vec qA, Vec qB, float last , int depth ) {
%int	set[4][3] = { 1,2,3, 3,4,5, 5,0,1, 1,3,5 };
%Vec	midA,midB, bestA,bestB, surfA,surfB;
%int	triA0,triB0, triA1,triB1, triA2,triB2;
%float	wsum, w, d, dif, dab, dmin;
%Vec	A0,A1,A2, B0,B1,B2;
%Vec	aim, aimA, aimB;
%Vec	a[8], b[8];
%Seg	ends;
%int	p,q;
%	aimA.zero();
%	aimB.zero();
%	wsum = 0.0;
%	FOR(i,on) FOR(j,on) {
%		d = allA[i]|allB[j]; w = 1.0/(d*d);
%		aimA += allA[i]*w; aimB += allB[j]*w;
%		wsum += w;
%	} // set target points <aimA>,<aimB> to weighted mean and project onto surface
%	aimA /= wsum; aimB /= wsum;
%	aimA = shell(aimA,centA,axisA,axesA,qA);
%	aimB = shell(aimB,centB,axisB,axesB,qB);
%	allA[on] = aimA; allB[on] = aimB; on++;	// append to current surface points
%	dmin = 9999.9;
%	FOR(i,on) FOR(j,on) { // find min of all current surface pairs
%		d = allA[i]|allB[j];
%		if (d<dmin) { dmin = d; p = i; q = j; }
%	}
%	aimA = allA[p]; aimB = allB[q];
%	FOR(i,4) // make midpoints for the 4 triangles in segments A and B
%	{ int	si0 = set[i][0], si1 = set[i][1], si2 = set[i][2];
%		midA = (sectA[si0]+sectA[si1]+sectA[si2])/3.0;
%		allA[on+i] = a[i] = shell(midA,centA,axisA,axesA,qA);
%		midB = (sectB[si0]+sectB[si1]+sectB[si2])/3.0;
%		allB[on+i] = b[i] = shell(midB,centB,axisB,axesB,qB);
%	}	// and append to collection of points <on> the surfaces 
%	on += 4;
%	d = bumping(on, allA,allB, centA,centB, axisA,axisB, axesA,axesB);
%	if (d>NOISE) { 
%		return Seg(Vec(d,0,9999.9)); // Seg.B.z > 9999 = bump 
%	}
%	dmin = 9999.9;
%	w = (float)depth;
%	if (depth > 1) w = sqrt(w);
%	FOR(i,4) // loop over the 4 midpoints in segment A
%	{ int	si0 = set[i][0], si1 = set[i][1], si2 = set[i][2];
%		midA = a[i];
%		FOR(j,4) // loop over the 4 midpoints in segment B
%		{ int	sj0 = set[j][0], sj1 = set[j][1], sj2 = set[j][2];
%			midB = b[j];
%			d = check_normal(midA,sectA[si0],sectA[si1],sectA[si2],midB,sectB[sj0],sectB[sj1],sectB[sj2]);
%			dab = w*sqrt(d)+(2.0/(1+w))*(midA|midB)+(aimA|midA)+(aimB|midB);
%			if (dab<dmin) {
%				dmin = dab;
%				triA0=si0; triA1=si1; triA2=si2;
%				triB0=sj0; triB1=sj1; triB2=sj2;
%				p = i; q = j;
%			}
%		}
%	}
%	// set best triangle pair for next iteration
%	A0 = sectA[triA0]; A1 = sectA[triA1]; A2 = sectA[triA2];
%	B0 = sectB[triB0]; B1 = sectB[triB1]; B2 = sectB[triB2];
%	surfA = a[p]; surfB = b[q];
%	dab = surfA|surfB;
%	dif = last-dab;
%	//if ((depth > 3 && last-dab < 0.001)||(depth > 6)) {
%	if (depth==3) { // go with whatever (4xfaster than above)
%		// NB for depth > 7, grid points get too close. For depth=9, on=92 (check Nhold)
%		d = bumping(on, allA,allB, centA,centB, axisA,axisB, axesA,axesB);
%		if (d>NOISE) { 
%			return Seg(Vec(d,0,9999.9)); // Seg.B.z > 9999 = bump 
%		}
%		dmin = 9999.9;
%		FOR(i,on) FOR(j,on) { // find min of all current surface pairs
%			d = allA[i]|allB[j];
%			if (d<dmin) { dmin = d; p = i; q = j; }
%		}
%		surfA = allA[p]; surfB = allB[q];
%		return Seg(surfA,surfB);
%	}
%	sectA[0] = A0; allA[on+0] = sectA[1] = shell((A0+A1)*0.5,centA,axisA,axesA,qA);
%	sectA[2] = A1; allA[on+1] = sectA[3] = shell((A1+A2)*0.5,centA,axisA,axesA,qA);
%	sectA[4] = A2; allA[on+2] = sectA[5] = shell((A2+A0)*0.5,centA,axisA,axesA,qA);
%	sectB[0] = B0; allB[on+0] = sectB[1] = shell((B0+B1)*0.5,centB,axisB,axesB,qB);
%	sectB[2] = B1; allB[on+1] = sectB[3] = shell((B1+B2)*0.5,centB,axisB,axesB,qB);
%	sectB[4] = B2; allB[on+2] = sectB[5] = shell((B2+B0)*0.5,centB,axisB,axesB,qB);
%	d = bumping(on+3, allA,allB, centA,centB, axisA,axisB, axesA,axesB);
%	if (d>NOISE) { 
%		return Seg(Vec(d,0,9999.9)); // Seg.B.z > 9999 = bump 
%	}
%	// pass sub-triangles (and append to surface collection)
%	ends = trisect(on+3,allA,allB,sectA,sectB,centA,centB,axesA,axesB,axisA,axisB,qA,qB,dab,depth+1);
%	return ends;
%}
%
%float bumping ( int n, Vec *allA, Vec *allB, Vec centA, Vec centB, Vec axisA, Vec axisB, Mat axesA, Mat axesB )
%{
%int	p, q = 0;
%float	d = 0.0, dmin = 999.9;
%Vec	surfA, surfB, quad = Vec(1,1,1);
%	FOR(i,n) // check if any points lie inside the other ellipsoid
%	{ float din;
%		din = in_egg(allA[i],centB,axisB,axesB);
%		if (din < 1.0-NOISE) { // A is in B (flag with q=1)
%			if (din<dmin) { dmin = din; p = i; q =  1; }
%		}
%		din = in_egg(allB[i],centA,axisA,axesA);
%		if (din < 1.0-NOISE) { // B is in A (flag with q=-1)
%			if (din<dmin) { dmin = din; p = i; q = -1; }
%		}
%	}
%	if (q>0) { // A is deeper inside B
%		surfB = shell(allA[p],centB,axisB,axesB,quad);
%		d = surfB|allA[p];
%		// Pi(n) Pr(dmin) Pt(A inside B by) Pr(d) NL
%	}
%	if (q<0) { // B is deeper inside A
%		surfA = shell(allB[p],centA,axisA,axesA,quad);
%		d = surfA|allB[p];
%		// Pi(n) Pr(dmin) Pt(B inside A by) Pr(d) NL
%	}
%	return d;
%}
%
%float in_egg ( Vec p, Vec c, Vec x, Mat axes ) {
%// Returns the fractional distance <d> of point <p> to the ellipsoid surface.
%// <d> < 1 = inside, <d> > 1 = outside
%// The ellipsoid has axes <M> (at 0 with lengths x)
%float	d;
%Vec	r, q = (p-c).get_frac(axes);		// q = components of <p> in basis set <M>
%	r = Vec(q.x*x.x, q.y*x.y, q.z*x.z);	// r = real-space position of <p> in <M>
%	d = r.x*r.x/(x.x*x.x) + r.y*r.y/(x.y*x.y) + r.z*r.z/(x.z*x.z); // surface definition
%	return d;
%}
%
%Vec shall ( Vec line, Vec cent, Vec axis, Mat axes, Vec quad ) {
%// returns the point on the ellipsoid (<axes>=ABC at 0) surface cut by a <line> from the <cent>re
%/*
%if the axes lie on XYZ then,
%	xx/AA + yy/BB + zz/CC = 1
%	x = pa, y = pb, z = pc
%	pp = 1/(aa/AA+bb/BB+cc/CC)
%	line = abc, surf = xyz
%*/
%Mat	frame;
%Vec	surf;
%float	A,B,C, a,b,c, p;
%	line -= cent;					// quadrant centroid shifted to origin
%	frame = Mat(axes.A.getVec()*quad.x, axes.B.getVec()*quad.y, axes.C.getVec()*quad.z);
%	surf = line*frame;				// rotated to A=X, B=Y, C=Z
%	A=axis.x, B=axis.y, C=axis.z;			// semi-axis lengths
%	a=surf.x, b=surf.y, c=surf.z;			// rotated point
%	p = 1.0/sqrt(a*a/(A*A)+b*b/(B*B)+c*c/(C*C));	// scale factor
%	surf *= p;					// to put point on ellipsoid surface
%	surf *= frame.get_trans();			// rotated back to ABC frame
%	return cent+surf;				// added back to centre
%}
%
%Vec sholl ( Vec line, Vec cent, float A, float B, Vec axis ) {
%// returns the point on the ellipsoid (<axes> = A>B=C at 0) surface cut by a <line> from the <cent>re
%/*
%in the plane of the major axis (A) and the <line> with components a,b to A,
%the point where the line cuts the surface has corresponding components g,h.
%Now	gg/AA + hh/BB = 1
%and	g/a = h/b
%so	gg = AA(1-hh/BB) = aa.hh/bb
%	AA - hh.AA/BB = hh.aa/bb
%	AA = hh.aa/bb + hh.AA/BB
%	hh = AA/(aa/bb+AA/BB)
%*/
%Vec	surf;
%float	AA=A*A, BB=B*B, aa,bb,b, d,ff,gg,hh;
%	line -= cent;					// shift line to origin
%	b = line.vec_to_line(axis);			// perpendicular dist from line to axis
%	bb = b*b;
%	ff = line.sqr();
%	aa = ff-bb;
%	hh = AA/(aa/bb+AA/BB);
%	gg = aa*hh/bb;
%	d = sqrt((gg+hh)/ff);
%	surf = line*d;					// extend <line> to ellipsoid surface
%	return cent+surf;				// added back to centre
%}
%
%Vec shell ( Vec line, Vec cent, Vec axis, Mat axes, Vec quad ) {
%float	ab, bc, ca, close = NOISE;
%	ab = axis.x - axis.y;
%	bc = axis.y - axis.z;
%	ca = axis.z - axis.x;
%	// check for oblate/prolate
%	if (ab*ab < close) return sholl(line,cent,axis.z,axis.x,axes.C);
%	if (bc*bc < close) return sholl(line,cent,axis.x,axis.y,axes.A);
%	if (ca*ca < close) return sholl(line,cent,axis.y,axis.z,axes.B);
%	// otherwise scalene
%	return shall(line,cent,axis,axes,quad);
%}


\subsection{Confining children in their parent object}

The \TT{keeper} routine keeps the children of the current object inside (or on) its
surface.  There are only the three basic shapes to consider and the treatment
of these uses much the same routines that were described in the previous section.

A parameter $keep$ is set from supplied inputs for each level that sets
the size of the step by which straying children are returned to their parental
object.   The sign of $keep$ is also used as a flag to modify the confinement
behaviour.  If the value of $keep$ 
is positive, then children are confined within spheres and ellipsoids but
are confined to the surface of a tube and these roles are reversed when
$keep$ is negative.   Having the default behaviour to locate children at the
surface of a tube is useful both for protein secondary structures and for
double-stranded nucleic acid segments.  (The tube diameter is automatically
set to the ideal value when these molecules are encountered).  

The use of a tube for a \Bs\ is less obvious as these elements can have a marked 
super-helical twist. However a slightly larger tube gives space for this twist
and indeed confinement on the surface encourages the chain to adopt a super-helix.   

\subsubsection{Spheres}

The {\tt packBall()} routine is used by \TT{keeper} to keep children inside a sphere and
provides a simple template of the other two routines ({\tt packTube()} and {\tt packEgg()}
described below).    The code (Box 8) is self-explanatory but contains two aspects that
require some elaboration.

\begin{figure}[h]
\centering
%\begin{singlespace}
\begin{tiny}
\begin{Verbatim}[frame=single]
int packBall ( Cell* cell, Cell* child, float strict )
{
       :
       radius -= model->sizes[child->level]*0.5;       // keep totally inside
       if (push < -NOISE) shell = 1;                   // confine to shell (+/-margin)
                else      shell = 0;                   // confine inside
       :
       shift = cell->xyz - child->xyz;                 // shift from child to zero
       d = shift.len();                                // distance from child to parent
       if (shell) {
               if (d>radius*margin && d<radius*margout) return 0; // in the margin zone
               if (d > radius) push = -push;           // outside the sphere (so pull)
       } else {
               if (d < radius*margout) return 0;       // within the sphere
       }
       shift *= push;
       child->move(shift);
       return 1;
}

\end{Verbatim}
\end{tiny}
%\end{singlespace}
\caption*{
Box 8:
\label{Fig:box8}
\begin{footnotesize}
{\bf Code for the {\ttfamily \bfseries packBall()} routine} that confines objects inside a sphere.
The objects are confined by their centres plus their radius or the shorter of their semi-axis lengths.
This only corresponds exactly to their surface for a sphere, so the ends of tubes and oblate ellipsoids
can extend beyond their enclosing surface.
The {\tt shell} flag sets the option for them to be confined at the surface.
\end{footnotesize}
}
\end{figure}

As implemented, the code subtracts the child radius from that of the parent,
so for spheres, the full body of the child will be kept inside the parent.  However for elongated objects,
only the radius normal to the axis of symmetry will be used so the ends of tubes and prolate ellipsoids
can stick-out, whereas oblate ellipsoids will be slightly over-confined.

To save a little computation time, a margin is maintained about the surface, within which no action is
taken.  This is set at $\pm10$\% ({\tt margin}=0.9, {\tt margout}=1.1).   Although it appears that this
will save only a few arithmetic operations, it should be remembered that all geometric operations
applied to objects (such as the {\tt move()} utility above) are
recursive and will be applied to the full underlying sub-tree of objects.
The margin also prevents rapid small in/out fluctuations of children that lie close to the surface
which can be visually disturbing.

\subsubsection{Tubes}

Tubes have a cylindrical body and hemi-spherical end-caps.  By default, children are constrained to 
lie on the surface of the cylinder and its caps.   If the normal from the child centre to the tube axis
intersects between the tube end-points then the child is shifted along the normal towards the surface.  
If outside the axial line-segment,
then it is shifted in the same way as described for a sphere (above), taking the nearest end-point as a
centre.  If the value of the $keep$ parameter is negative, then children that lie inside the tube are left
unmoved.  The same margin zone described above for spheres is also implemented.

An exception is made for the children of protein loop regions (which also have a
tube object associated with them) but they are much less constrained and are only held
inside the tube (not on its surface) with 1/10 the weight of the equivalent \AH\ and \Bs.  
In addition, the end-cap constraints are not enforced.

An exception is also made for double-stranded nucleic acid segments where the tube enclosing the
double helix is a domain level object (atomic-2).   It is therefore quite undesirable to have the
base-pair 'secondary-structure' tubes confined to this surface but rather their children (the pair
of phosphates) should be on the surface.  To implement this, a wrapper routine ({\tt packBase()})
is used to call {\tt packTube()} with a skipped generation as: {\tt packTube(grandparent,child,...)}
instead of the normal {\tt packTube(parent,child,...)}.  {\tt packBase()} also refines the P---P
distance across the basepair and sets the axis end-points of their tube to track the phosphates.
As these constraints have no chiral component, the torsion angle about the axis for baspaired
phosphates is also refined, so maintaining the correct hand of the double helix.

\subsubsection{Ellipsoids}

For ellipsoids, the \TT{keeper} routine follows the template for the sphere but uses the utility {\tt inEgg()},
which was described above, to decide who is out and who is inside.   It will be recalled that
{\tt inEgg()} needs only the distance between the two foci of the ellipse-of-rotation to do this
and so requires little computation time.

Unlike the tube end-caps, where the nearest centre was used to set the shift direction, instead, a
weighted combination of the distances to both foci are used.   The weights are taken as the inverse distance
to each focus: so if the child lies closer to focus-1, it will have a larger weight
on the component of the displacement vector in the direction of focus-1, and {\em vice versa}. 

%#include "util.hpp"
%#include "geom.hpp"
%#include "cell.hpp"
%#include "data.hpp"
%
%int  packBall ( Cell*, Cell*, float );
%int  packTube ( Cell*, Cell*, float );
%void packBase ( Cell*, Cell*, float );
%float inEgg ( Vec, Vec, Vec, float, Vec& );
%float inEgg ( Vec, Vec, Vec, float );
%float inEgg ( Vec, Seg, float );
%int packEgg ( Cell*, Cell*, float );
%
%float margin = 0.9, margout = 1.0/margin;
%
%void center ()
%{
%Cell	*world = Cell::world;
%	DO(i,world->kids) { Cell *child = world->child[i];
%                if (child->empty) continue;
%		child->group();
%	}
%}
%
%void keeper ( Cell *cell )
%{
%int	m = cell->model,
%	moltype = Data::model[m].moltype,
%	subtype = Data::model[m].subtype,
%	dna = moltype*subtype;
%	DO(i,cell->kids) // push the children inside
%	{ Cell *child = cell->child[i];
%	  int	type = cell->type, sort = cell->sort, lost = 0;
%	  float s, strict, balance;
%                if (child->empty) continue;
%/* ?
%		if (chain[level] > 0 && chain[level+1] > 0) {   // in a chain of chains (don't push ends in)
%			if (child == cell->starts || child == cell->finish) continue;
%		}
%*/
%		strict = 1.0;
%		switch (type) {
%			case 0 :	// dummy sphere
%				lost = packBall(cell,child,1.0);
%			break;
%			case 1 :	// simple sphere
%				lost = packBall(cell,child,strict);
%			break;
%			case 2 :	// SSE tube
%				if (sort) s = strict; else s = 0.1*strict;
%				if (moltype==1) {
%					packBase(cell,child,s);
%				} else {
%					lost = packTube(cell,child,s);
%				}
%			break;
%			case 3 :	// Ellipsoid
%				if (cell->sort == E/2) {	// same as a sphere
%					lost = packBall(cell,child,1.0);
%				} else {
%					lost = packEgg(cell,child,1.0);
%				}
%			break;
%		}
%	}
%	DO(i,cell->kids) keeper(cell->child[i]);
%}
%
%void packBase ( Cell *cell, Cell* child, float strict ) {
%// <cell> = 'basepair secondary structure', child = base (P), <pa> = segment (domain)
%Cell	*pa = cell->parent;
%Vec	mid, shift;
%	if (pa->type != 2 ) return;
%	if (child->level != depth) return;
%	// confine atoms to level-2 tube (DNA segment is at domain level)
%	if (cell->sort == 0) strict *= 0.1;
%	packTube(pa,child,strict);
%	if (cell->sort == 0) { // reset loop ends
%		shift = (cell->junior->xyz - cell->senior->xyz)/4.0;
%		cell->endN = cell->xyz - shift;
%		cell->endC = cell->xyz + shift;
%		return;
%	}
%	// reset basepair tube ends
%	part2cells(cell->child[0],cell->child[1],2.7,0.1);
%	cell->xyz = cell->child[0]->xyz & cell->child[1]->xyz;
%	shift = (cell->child[1]->xyz - cell->child[0]->xyz)*0.7/2.0;
%	cell->endN = cell->xyz - shift;
%	cell->endC = cell->xyz + shift;
%	// shift basepair tube centre towards axis
%	mid = (cell->xyz).vec_on_line(pa->endN,pa->endC);
%	shift = mid - cell->xyz;
%	cell->move(shift*0.1);
%}
%
%int packBall ( Cell* cell, Cell* child, float strict )
%{
%int	shell;
%Vec	shift;
%Data	*model = Data::model+cell->model;
%float	radius = model->sizes[cell->level]*0.5,
%	push   = model->keeps[cell->level]*strict,
%	d;
%	if (cell->level==Data::depth) return 0;
%	if ((int)cell->endN.z == 1234) return 0;	// ends not set yet
%	if ((int)cell->endC.z == 1234) return 0;	// ends not set yet
%	radius -= model->sizes[child->level]*0.5;	// keep totally inside
%	if (push < -NOISE) shell = 1;			// confine to shell (+/-margin)
%		 else	   shell = 0;			// confine inside
%	shift = cell->xyz - child->xyz;			// shift from child to zero
%	d = shift.len();
%	if (shell) {
%		if (d>radius*margin && d<radius*margout) return 0;
%		if (d > radius) push = -push;		// outside the sphere
%	} else {
%		if (d < radius*margout) return 0;	// within the sphere
%	}
%	shift *= push;
%	if (shift.sqr()<NOISE) return 0;
%	child->move(shift);
%	return 1;
%}
%
%int packTube ( Cell *cell, Cell *child, float strict )
%{
%int	in, shell, closed = 1;
%Vec	shift, over, temp;
%float	dlast, dnext, dif, d, pale;
%Data	*model = Data::model+cell->model;
%float	radius = model->sizes[cell->level]*0.5,
%	push   = model->keeps[cell->level]*strict;
%int	moltype = model->moltype,
%	subtype = model->subtype,
%	protein = 0;
%	if (moltype==0 && subtype==1) protein = 1;
%	if (cell->level==Data::depth) return 0;
%	if ((int)cell->endN.z == 1234) return 0; // ends not set yet
%	if ((int)cell->endC.z == 1234) return 0; // ends not set yet
%	if (protein && cell->level==depth-1) { // apply SSE factor
%		if (cell->sort==0) radius *= loopTHIC;
%		if (cell->sort==1) radius *= alphTHIC;
%		if (cell->sort==2) radius *= betaTHIC;
%	}
%//	radius -= model->sizes[child->level]*0.5; // keep totally inside
%	pale = radius;
%	if (push < -NOISE) shell = 0;		// confine inside
%		 else	   shell = 1;		// confine to shell (+/-margin)
%	if (shell) push = -push;
%	if (protein && cell->sort==0) {
%		shell = closed = 0;	// protein loops always have open ends and no shell
%		push = -push;		// mimic -ve keep value from param file
%	}
%	if (vdif(cell->endN,cell->endC) < NOISE) return 0;
%	if (closed) {
%		dlast = cell->endN|child->xyz;
%		dnext = cell->endC|child->xyz;
%		if (!shell) { // make quick pre-check at ends
%			if (dlast < pale) return 0;
%			if (dnext < pale) return 0;
%		}
%	}
%	in   = child->xyz.vec_in_seg (cell->endN, cell->endC); // in the line segment
%	d    = child->xyz.vec_to_line(cell->endN, cell->endC); // dist to extended line
%	over = child->xyz.vec_on_line(cell->endN, cell->endC); // image on extended line
%	if (closed) { // confine within segment
%		if (in) { // over line segment
%			if (d < pale) { // inside the tube
%				if (!shell) return 0;	// inside is OK
%				if (d < pale*margin) {	// too deep inside
%					dif = fabs(pale-d);
%					push *= dif;
%				} else { return 0; }	// in the shell margin
%			} else {	// outside the tube
%				push = -push;	// pull in
%			}
%			shift = over - child->xyz;
%		} else { // over an end-cap (so find which one)
%			if (dlast < dnext) {		// over endN
%				shift = cell->endN - child->xyz;
%				d = cell->endN | child->xyz;
%			} else{				// over endC
%				shift = cell->endC - child->xyz;
%				d = cell->endC | child->xyz;
%			}
%			if (d < pale) { // inside the cap
%				if (!shell) return 0;	// inside is OK
%				if ( d < pale*margin) { // too deep inside
%					dif = fabs(pale-d);
%					push *= dif;
%				} else { return 0; }	// in shell margin
%			} else {	// outside the tube
%				push = -push;	// pull in
%			}
%		}
%	} else { // confine within extended tube
%		if (d < pale) { // inside the tube
%			if (!shell) return 0;	// inside is OK
%			if (d < pale*margin) {	// too deep inside
%				dif = fabs(pale-d);
%				push *= dif;
%			} else { return 0; }
%		}
%		shift = over - child->xyz;
%	}
%	shift.setVec(push);
%	if (shift.sqr()<NOISE) return 0;
%	child->move(shift);
%	return 1;
%}
%
%float inEgg ( Vec cell, Vec endN, Vec endC, float len, Vec &move )
%// returns a value that is +ve outside and -ve inside the ellipsoid (not surface distance)
%// cell = point, endN,endC = poles, dB = diameter across minor axes, move = returned shift
%{
%float	dB, rB, dA, rA;
%Vec	p,q,r, cent, axis;
%float	a, b, c, d, e, f, g;
%float	v,w,x,y,z;
%int	apply = 1;
%	if (len<0) { len = -len; apply = 0; }
%	cent = endN & endC;	// set centre
%	axis = endC - endN;	// axis between poles
%	dA = endN|endC;		// dist between poles
%	dB = len;		// diameter across minor axis
%	rA = dA*0.5;		// major (rA) and...
%	rB = dB*0.5;		// minor (rB) semi-axis lengths
%	x = y = 1.0; z = dA/len;
%	// bubble sort axes to x>y>z
%	if (x<y) { w=x; x=y; y=w; }
%	if (y<z) { w=y; y=z; z=w; }
%	if (x<y) { w=x; x=y; y=w; }
%	v = y/x; w = z/x;
%	d = rA;	// major semi-axis length
%	a = 1.0-v; b = 1.0-w; // fractional axis lengths relative to X
%	if (a*a+b*b < 0.04) { // sphere-ish (both minor axes over 0.8-ish)
%		g = 3.0*d/(1.0+v+w);	// mean sphere radius
%		c = cell|cent;
%		if (apply) move = (cent-cell).norm();	// move towards centre
%		return c-g;
%	}
%	if (v > 0.5+0.5*w) {	// oblate
%		g = d;
%		d = d/w*(1.0+v)*0.5; // force radial symmetry about Z (min)
%		p = cell-cent; q = axis; r = p^q;
%		axis = r^q;	// axis now lies on cell-cent-pole plane
%	} else {		//prolate
%		g = d*0.5*(v+w);	// force radial symmetry about X (max)
%	}
%/*
%                             * cell (external point)
%                     ..-+-../
%                .    d /|  /    .           d = focus pole distance
%              .       /b| /       .         b = minor axis length/2
%             :       /  |/c        :        c = foucs cent distance
%        endN |------x---+---x------| endC   x = focii on major axis
%                       cent                 a = major axis length/2
%	length of focus1-surface-focus2 path:
%	at major axis = c+a+(a-c) = 2a
%	at minor axis = 2d, dd = bb+cc
%	since the paths are equal: d = a;
%	so	cc = dd-bb = aa-bb
%	and 	c = sqrt(aa-bb)
%*/
%	c = sqrt(d*d-g*g);	// distance from centre to focii
%	axis.setVec(c);		// set axis to length c
%	p = cent+axis;		// up axis to focus1
%	e = cell|p;		// dist to focus1
%	q = cent-axis;		// down axis to focus2
%	f = cell|q;		// dist of focus2
%	if (apply) { // move is p*f+q*e (swap e/f weights to bias towards nearest focus)
%		p -= cell;	// vect to focus1
%		q -= cell;	// vect to focus2
%		p.setVec(f);
%		q.setVec(e);
%		move = (p+q).norm();
%	}
%	return 1.4*(0.5*(e+f)-d);
%}
%
%float inEgg ( Vec cell, Vec endN, Vec endC, float len )
%{ // just return the distance (-ve len = no movement)
%Vec	x;
%	return inEgg(cell,endN,endC,-len,x);
%}
%
%float inEgg ( Vec cell, Seg ends, float len )
%{ // just return the distance (-ve len = no movement)
%Vec	x;
%	return inEgg(cell,ends.A,ends.B,-len,x);
%}
%
%int packEgg ( Cell *cell, Cell *child, float strict )
%{
%Vec	shift;
%int	shell,
%	level = cell->level,
%	type = cell->type,
%	sort = cell->sort;
%Data	*model = Data::model+cell->model;
%float	radius = model->sizes[cell->level]*0.5,
%	push   = model->keeps[cell->level]*strict,
%	d, dout;
%	if (cell->level==Data::depth) return 0;
%	if ((int)cell->endN.z == 1234) return 0;	// ends not set yet
%	if ((int)cell->endC.z == 1234) return 0;	// ends not set yet
%	if (push < -NOISE) shell = 1;			// confine to shell (+/-margin)
%		else	   shell = 0;
%	d = cell->endN | cell->endC;
%	if (d < NOISE) return 0;			// no axis length
%	if (cell->ends < 0) { float z = Data::Eratio[sort];
%		radius = 0.5*d/z;
%	}
%	if (shell==0) {
%		d = cell->xyz|child->xyz;
%		if (d < radius*margin) return 0;	// inside the inscribed sphere
%	}
%	dout = inEgg(child->xyz,cell->endN,cell->endC,radius*2.0,shift);
%	if (shell) {
%		if (dout>-0.1 && dout<0.1) return 0;	// close enough to surface
%		if (dout>0.0) push = -push;		// switch to pulling in
%	} else {
%		if (dout < 0.0) return 0;		// inside
%	}
%	if (dout > 0.0) push *= sqrt(dout);		// go easy on far-away children
%	shift *= push;					// push back along resultant
%	if (shift.sqr()<NOISE) return 0;
%	child->move(shift);
%	return 1;
%}
%
%/*
%sortTube(Cells *cell) 
%{
%int	i, n = cell->kids;
%int	run=0, in=0;
%Vec	x,y,z,ave;
%	vinit(&ave);
%	for (i=0; i<n-1; i++) { Cells *b1,*b2, *p1,*p2;
%		b1 = cell->child[i];
%		b2 = cell->child[i+1];
%		if (b1->link[0]==0) continue;
%		if (b2->link[0]==0) continue;
%		p1 = b1->link[0];
%		p2 = b2->link[0];
%		if (b1->id == b2->id-1 && p1->id == p2->id+1) {
%			//Pi(b1->id) Pi(p1->id) Pi(b2->id) Pi(p2->id) NL
%			vave(b1->xyz,p1->xyz,&x);
%			vave(b2->xyz,p2->xyz,&y);
%			vsub(x,y,&z);
%			vsum(z,&ave);
%			run++; in++;
%		}
%		if (b1->id == b2->id+1 && p1->id == p2->id-1) {
%			//Pi(b1->id) Pi(p1->id) Pi(b2->id) Pi(p2->id) NL
%			vave(b1->xyz,p1->xyz,&x);
%			vave(b2->xyz,p2->xyz,&y);
%			vsub(x,y,&z);
%			vsum(z,&ave);
%			run--; in++;
%		}
%	}
%	vdiv(&ave,(float)in); vnorm(&ave);
%	// recheck all against consensus direction (ave)
%	for (i=0; i<n-1; i++) { Cells *b1,*b2, *p1,*p2; float d;
%		b1 = cell->child[i];
%		b2 = cell->child[i+1];
%		if (b1->link[0]==0) continue;
%		if (b2->link[0]==0) continue;
%		p1 = b1->link[0];
%		p2 = b2->link[0];
%		if (b1->id == b2->id-1 && p1->id == p2->id+1) {
%			vave(b1->xyz,p1->xyz,&x);
%			vave(b2->xyz,p2->xyz,&y);
%			vsub(x,y,&z); vnorm(&z);
%			d = vdot(z,ave);
%			if (d < -0.2) { // wrong way so swap
%				vcopy(b1->xyz,&x); vcopy(b2->xyz,&(b1->xyz)); vcopy(x,&(b2->xyz));
%				vcopy(p1->xyz,&x); vcopy(p2->xyz,&(p1->xyz)); vcopy(x,&(p2->xyz));
%			}
%		}
%		if (b1->id == b2->id+1 && p1->id == p2->id-1) {
%			vave(b1->xyz,p1->xyz,&x);
%			vave(b2->xyz,p2->xyz,&y);
%			vsub(x,y,&z); vnorm(&z);
%			d = vdot(z,ave);
%			if (d < -0.2) { // wrong way so swap
%				vcopy(b1->xyz,&x); vcopy(b2->xyz,&(b1->xyz)); vcopy(x,&(b2->xyz));
%				vcopy(p1->xyz,&x); vcopy(p2->xyz,&(p1->xyz)); vcopy(x,&(p2->xyz));
%			}
%		}
%	}
%}
%
%groupCell (Cells *cell, int level)
%{
%Vec	centre, shift;
%int	i,j,k, m,n, id, type, sort;
%float	far = -cell->far/(float)data[3];
%float	strict, bias = (float)(cell->level-1);
%	if ((int)cell->endN.z==1234 || (int)cell->endC.z==1234) return;
%	if (cell->empty) return;
%	n = cell->kids;
%	if (n==0) return;
%	id = cell->id;
%	type = cell->type;
%	sort = cell->sort;
%	if (type<0) type = -type;
%	bias = 1.0 - exp(-bias*bias*0.1); // small for top levels to increase selection
%	if (level > 0) shifter(cell);
%	// readjust centres (except for world) going down
%	//
%	for (i=0; i<n; i++) {
%		groupCell(cell->child[i],level+1);
%	}
%	//
%	// gather lost chlidren back to family coming up
%	if (data[0] <= 0) return;
%	if (cell->solid > 0) bias = 2.0; else bias = 0.5; // 4x more like to check cthru cell
%	if (drand48()*bias > exp(far)) return; // distant cells (small exp(far)) checked less
%	// set the model parameters
%	model = cell->model;
%	if (level==0) model = cell->child[0]->model; // world model type is ambiguous
%	m = model*M*N+N;
%	moltype = data[m];
%	align = data+m+N*1; class = data+m+N*2;
%        sizes = data+m+N*3; bumps = data+m+N*4; links = data+m+N*5; chain = data+m+N*6;
%	kicks = data+m+N*7; keeps = data+m+N*8; repel = data+m+N*9; bonds = data+m+N*10;
%	for (i=0; i<N; i++) keep[i] = 0.01*(float)keeps[i];
%	if (rna && type==2 && sort==1) sortTube(cell);
%	for (i=0; i<n; i++)
%	{ Cells *child = cell->child[i];
%	  int	lost = 0; float balance;
%	  	if (data[0] < 0) break;  // don't push before setup is done
%		if (chain[level] > 0 && chain[level+1] > 0) {   // in a chain of chains (don't push ends in)
%			if (child == cell->starts || child == cell->finish) continue;
%		}
%		strict = 1.0;
%		//if (child->type==2 && child->sort==0) continue; // don't push loops
%		switch (type) {
%			case 0 :	// dummy sphere
%				lost = packBall(cell,child,1.0);
%			break;
%			case 1 :	// simple sphere
%				lost = packBall(cell,child,strict);
%			break;
%			case 2 :	// SSE (tube)
%				if (sort && cell->endN.z+cell->endC.z < 1000.0) {
%					vave(cell->endN,cell->endC, &(cell->xyz));
%				}
%//				{ Vec	shift, mid; // bring endpoints in line
%//				  float len = 0.1*(float)sizes[level];
%//					if (sort==1) len *= 3.0/2.0;
%//					vave(cell->endN,cell->endC, &mid);
%//					vsub(cell->xyz,mid, &shift);
%//					vsum(shift, &(cell->endN));
%//					vsum(shift, &(cell->endC));
%//					separate(&(cell->endN),&(cell->endC),len,0.1);
%//				}
%				if (moltype==0) { // protein
%					if (sort==0) strict = 0.01; // loose loop
%					if (sort==1) strict = 1.00; // tight for alpha
%					if (sort==2) strict = 0.10; // looser for beta (to allow bend)
%				}
%				if (moltype==1) { // nucleic
%					strict = 1.0;
%				}
%				lost = packTube(cell,child,strict);
%				if (sort==0) lost = 0; // allow lost children in loops
%			break;
%			case 3 :	// Ellipsoid
%				if (cell->sort < E/2-1 || cell->sort > E/2+1) {
%					lost = packEgg(cell,child,1.0);
%				} else {	// effectively a sphere
%					lost = packBall(cell,child,1.0);
%				}
%			break;
%		}
%	}
%}
%*/


\subsection{Bonds and links}

The maintenance of bond and link lengths is very similar and the two routines,
\TT{bonder} and \TT{linker}, that implement this task will be considered together.
Both recursively traverse the object tree looking for things to fix.

\subsubsection{\TT{bonder}}

\paragraph{Bond lengths}

The \TT{bonder} simply checks if an object has any assigned bonds and if so, uses
the utility {\tt part2cells()} to push them towards their assigned bond length.

\paragraph{Nucleic acid exceptions}

Exceptions need to be made when bonding tubes in nucleic acids, which occur both at
the secondary structure level as basepairs and the domain level
as segments of double helix. 

For basepairs, if these are part of a double helix, their 'bond-length' is the distance
between their mid-points (object centre) which is refined to an ideal base-stacking separation.  
Outside a base-pair, say in a loop region, the 'secondary structure', like a loop in a protein,
can contain multiple nucleotides and no bond length is refined.

At the domain level, double-stranded DNA segments will always be bonded end-to-end
at a specific distance that allows the helix to run continuously from one segment to
the next.   On the other hand, when the segment is an RNA stem-loop, the chain can enter
and exit the same end of the tube or, with an insertion, even through the side.


\subsubsection{\TT{linker}}

\paragraph{Breaking links}

The \TT{linker} follows the same basic outline as the \TT{bonder} but with the main
difference that links can be made and broken during the simulation.   The dynamic creation
of links is not a built-in feature of \NAME\ and must be provided through the user-supplied
\TT{driver} routine.   However, if a link becomes over stretched, it is automatically destroyed in
the \TT{linker}.    The default length of a link is the bump diameter and the default extension
is 50\%, beyond which the link breaks.

\paragraph{Preset link lengths}

Local links are automatically created for standard secondary structures,  not only between the H-bonded
connections in the \AH, i---i+3 and i---i+4, but also between the i-1---i+1 separation along a \Bs.
However, the non-local links between strands in a \BS\ must be user defined.

\clearpage
\section{Examples and Applications}

\subsection{Collision detection test data}

\subsubsection{Colliding Hilbert chains}

For test data,
a general model of a simple macromolecule was based on a linear chain of atoms.
This chain was then 'packaged' into a hierarchy of spherical objects, each of which contained
eight children arranged as a cube.   To maintain equal bond-lengths between the atoms, the path of the
chain followed a recursive Hilbert curve, in which each level of the hierarchy is identical\footnote{
A Hilbert curve ({\tt https://en.wikipedia.org/wiki/Hilbert\_curve}) is the spatial equivalent of a 
Gray code ({\tt https://en.wikipedia.org/wiki/Gray\_code}) in which successive elements are
only one step away from their neighbours.
}.   This arrangement generates a homogeneously packed chain which allows the effects of
collisions to be monitored without the added complication of variable internal structure and density.

Collisions between these objects were then engineered by applying an external
displacement to propel two identical objects into each other.   To avoid a direct "head-on"
collision, the objects were displaced by half their radius from their line of approach.
As the chain forms a cube, this means that the collision surface encompasses half a face of each cube.
During the collision, the number of bumping atoms was monitored between the two objects
and also within each object.

\paragraph{8+8 crash:\\}

The model was initially tested with only a hard repulsion at the atomic level.
However, without the protective shell of their parent, the bonds between atoms were flexible enough 
to allow bonded pairs to transiently pass through each other resulting 
in interpenetrating chains, even though these still preserved their steric and average bond lengths.

To investigate the contribution of the soft repulsion component of higher level objects,
the first construct of interest involves the collision of two cubes of eight atoms.  The
repulsion strength at both levels was set to a value of 1 for both hard and soft modes
(although the atomic level only has hard repulsion).   With these values, the containing
spherical shells repelled each other before the atoms could make contact.

The $soft$ parameter value was then decreased, allowing inter-penetration of the high
level spheres,  until the internal atoms made contact.   This occurred when $soft = hard/5$
but most of the displacement still derived from the high-level soft repulsion component
and the internal arrangement of the atoms was almost unchanged.   With no soft repulsion,
the atomic configuration was markedly displaced and as a compromise, $soft = hard/10$
was taken as a combination that allowed a roughly equal contribution from each level.

\paragraph{64+64 crash:\\}

The next level of model considered was the 64 atom chain (Figure 1(a)) and keeping the values established
above for the first level in the hierarchy, an equivalent evaluation was made for the second level.
As with the smaller test object, the first level spheres initially made contact when $soft = hard/5$,
however, because of the added buffering effect of the first-level spheres, the atoms remained
well separated between the two colliding objects even when $soft = hard/10$.  To compensate for
this additive contribution, the $hard$ parameter value on both levels was halved and the 10\%
ratio to the $soft$ parameter retained giving $hard = 0.5, soft = 0.05$.  
(Or 50:5, as a percentage of the atomic value). 

\begin{figure}
\centering
\subfigure[64+64]{
\epsfxsize=190pt \epsfbox{figs/cube/crash2.eps}
}
\subfigure[512+512]{
\epsfxsize=192pt \epsfbox{figs/cube/crash3.eps}
}
\subfigure[4096+4096]{
\epsfxsize=390pt \epsfbox{figs/cube/crash4.eps}
}
\caption[]{
\label{Fig:cubes}
\begin{footnotesize}
{\bf Idealised chain collisions} of increasing size. $a$) Two 64 atom chains are directed into each
other from left and right.   Groups of 8 atoms are enclosed in 8 transparent green virtual spheres
which in turn are enclosed in a larger red sphere.  $b$) A third level is added to the hierarchy
with the virtual spheres and atoms now coloured by their collision state: dark-blue designates no
clash while cyan to green to yellow colours are associated with collisions of increasingly distant
relatives.  Cyan = same parent (cousins), green = second cousins, yellow = third. $c$) The number
of levels is increased to four but with smaller atoms and the virtual spheres not rendered to allow
the distribution of clashes to be visualised at the atomic level.  The colliding bodies remain distinct
with only occasional flashes of red (fourth cousins) indicating clashes between atoms in the collision
interface (which runs bottom left to top right).   The distortion of the structures has been 
distributed evenly through many localized (green) interactions.
\end{footnotesize}
}
\end{figure}


\paragraph{512+512 crash:\\}

The evaluation protocol was extended to the 3-level hierarchy of 512 atoms per chain (Figure 1(b)).
Transferring the values from the previous test again led to a lack of direct contact at the
atomic level and these were reduced to $hard = 0.2$, keeping the $soft = hard/10$ ratio.
This produced a result at the mid-point of the collision (when the centroids of the bodies
draw level on their collision course) that was comparable to the smaller systems.

\paragraph{4096+4096 crash:\\}

For the largest model tested, with the chain packaged into 4 levels of containers,  the
progression of reducing the values of the $hard$ and $soft$ parameters was continued.
However, this led to a marked number (100s) of steric violations at the atomic level both
between and within the colliding bodies.   Keeping the two parameters at their previous
levels ($hard = 0.2$, $soft = 0.02$) the number of clashes between the bodies decreased
(10s) but the number of internal violations remained high.   This can be seen in Figure 1(c)
as green coloured atoms and indicates that the distortions produced by the collision are
being distributed through the objects rather than concentrated at the collision interface.

As this model extends beyond the normal size range of compact biological molecules,
no further experimentation was made.   Of greater interest is the degree of distortion 
observed in the "crumple-zone" and to investigate this a more realistic protein model
was used.


\subsubsection{Colliding multiple protein domains}

Progressing to a more biologically realistic system and also to introduce a variety
of container shapes, the small chemotaxis-Y protein (PDB code: {\tt 3chy}), was used
and modelled with tubes to contain its secondary structure elements and an ellipsoid
to contain the protein.    The structure was also stabilised with 'hydrogen-bond'-like
links between the $i..i+3$ and $i..i+4$ positions in the \AHs\ and links between
hydrogen-bonded positions in the \BS. (Figure 2(a)).

A series of multi-domain models were then constructed with the protein chain as a
node on a Hilbert curve giving models of 1, 8 and 64 domains.   The link between 
domains was also optionally broken, making the domains equivalent to subunits.
Collisions between these constructs were engineered as above, with the coordinates
being saved at the start of the run and at the end, after the structures were well
past each other.    To monitor the distortion experienced by the domains/subunits
during the collision, each domain in the starting structure was compared to each
domain in the final structure and the smallest, mean and largest root-mean-square
deviation (RMSD) recorded. 

\paragraph{Single domain collision:\\}

Two single domain structures were collided using the same parameters as determined
for the equivalent sized Hilbert chains of the previous subsection ($hard = 1.0$, $soft = 0.1$).
Comparing combinations of the two starting and two final structures, the mean RMS
deviation was 3.6\AA , which is not far in excess of the 2.4\AA\ mean deviation seen
when the two structures travel the same distance but do not collide.   For a protein
of this size, with any RMSD under 5\AA, the structures retain a clear correspondence. 

Increasing the $soft$ parameter to 0.2 led to less distortion (mean RMSD = 3.1) which
is closer to the un-collided value.   While, retaining the same $hard:soft$ ratio
with $hard = 0.5$ gave a deviation of 4.0\AA, which is still acceptable and only
when the parameter values were dropped as low as $hard = 0.5$, $soft = 0.01$ was the
5\AA\ 'threshold' exceed.  

\begin{figure}
\centering
\subfigure[]{
\epsfxsize=190pt \epsfbox{figs/prot/net3chy.eps}
}
\subfigure[]{
\epsfxsize=190pt \epsfbox{figs/prot/bad3chy.eps}
}
\caption[]{
\label{Fig:bumps}
\begin{footnotesize}
{\bf Small globular protein Che-Y} used for testing.
$a$) The \CA\ backbone is drawn in a ball-and-stick representation with secondary structures
contained in transparent tubes: red = \AH, green = \Bs s and cyan = loops.  Residues in these
tubes are restrained to lie at the surface but only weakly for loops.   Thin lines connect
residues in \A\ and \B\ elements that are hydrogen-bonded.   In some of the tests, an additional 
link was added between the two loop segments that connect domains (horizontal line lower-front).
The ellipsoid that contains the whole domain is rendered as a feint mesh.
$b$) Superposition of structure before and after collision represented by a stick \CA\ backbone
and ball-and-stick backbone, respectively.   The chains are coloured from amino (blue) terminus 
through the spectrum to the carboxy (red) terminus.  The largest deviation is seen in the 
C-terminal \AH\ which contributed most to the overall 5\AA\ root mean square deviation.
This level was set as a target threshold to remain below. 
\end{footnotesize}
}
\end{figure}

\paragraph{8+8 domain collision:\\}

The same approach was applied to the larger 8-domain construct over a series of collisions 
ranging from a glancing blow to almost head-on collision.  The tests were repeated
both with the domains in a continuous chain and as separate (unbonded) subunits.
The repulsion of the highest level sphere was set initially low with $hard=0.2, soft=0.1$
and the two $hard$/$soft$ parameter combinations applied to the secondary structure and domain 
levels were tested.  (Table 1).

The mean RMSD over the domains before and after the collision seldom exceeded the (self-imposed)
threshold if 5\AA\ RMSD for both parameter combinations and, as would be expected, the deviations
were slightly reduced when the domains were treated as subunits.   However, some of the worst
distortions seen in the full (almost head-on) collisions had markedly elevated RMSD values, up to 8\AA.
Despite excluding the 5 residue amino and 5 residue carboxy terminal linking segments from the comparison
(which often must diverge in different directions), examination of these worst cases revealed that a
large component of the error often came from displacement of the un-tethered C-terminal \AH.
(Figure 2(b)).

To reduce this source of error, a link as added between the mid-points of the 5-residue N- and C-terminal
segments that connect domains.  However, this had little effect, and even led to a slight overall increase in RMS
deviations.   On visual examination the distortions appeared to remain associated with the terminal helix
which was still able to be markedly displaced despite the C-terminal tether but now this occurred more
at the expense of disrupting other neighbouring secondary structure elements.

To allow contact at the atomic level between the colliding objects,
it is desirable to limit the repulsion from the higher levels of the hierarchy.
With the $hard$:$soft$ parameter combinations used above of 20:10, 50:20, 50:20 for the protein, domain 
and secondary structure levels respectively (as a percentage of the atomic level), the colliding surfaces
were able to make contact but without serious deformation occurring.   These values were adopted for
all further simulations.

\begin{table}
\centering
\begin{tabular}{l|rrr|rrr||rrr|rrr|}
$a$  & \multicolumn{12}{c}{\bf hard:soft = 50:20} \\
     & \multicolumn{6}{|c||}{\bf subunit} & \multicolumn{6}{c|}{\bf domains} \\
     & \multicolumn{3}{|c|}{no link} & \multicolumn{3}{c||}{link on}  & \multicolumn{3}{c|}{no link} & \multicolumn{3}{c|}{link on}\\
\hline
miss & 2.29 & 2.82 & 3.32 &   2.27 & 2.81 & 3.48 &      2.40 & 3.06 & 4.16 &   2.10 & 3.12 & 4.45 \\
clip & 2.31 & 3.02 & 3.68 &   2.61 & 3.04 & 3.58 &      2.34 & 3.72 & 5.17 &   2.87 & 3.93 & 5.45 \\
half & 2.60 & 3.82 & 5.01 &   2.48 & 3.84 & 5.18 &      2.48 & 3.84 & 5.18 &   3.02 & 4.71 & 8.28 \\
full & 4.19 & 5.13 & 6.28 &   3.48 & 5.26 & 7.01 &      3.74 & 5.25 & 7.09 &   3.71 & 5.72 & 8.47 \\
\hline \hline
       \multicolumn{13}{c}{} \\
$b$  & \multicolumn{12}{c}{\bf hard:soft = 100:20} \\
     & \multicolumn{6}{|c||}{\bf subunit} & \multicolumn{6}{c|}{\bf domains} \\
     & \multicolumn{3}{|c|}{no link} & \multicolumn{3}{c||}{link on}  & \multicolumn{3}{c|}{no link} & \multicolumn{3}{c|}{link on}\\
\hline
miss & 2.36 & 2.91 & 3.50 &   2.06 & 2.75 & 3.27 &      2.08 & 2.93 & 4.18 &   2.27 & 3.11 & 4.25 \\
clip & 2.50 & 3.04 & 3.62 &   2.54 & 3.08 & 3.81 &      2.35 & 3.64 & 5.14 &   2.61 & 3.79 & 5.45 \\
half & 2.63 & 3.60 & 4.83 &   2.35 & 3.68 & 4.76 &      2.73 & 4.40 & 7.63 &   2.78 & 4.37 & 6.65 \\
full & 3.80 & 4.66 & 5.48 &   3.52 & 4.56 & 5.49 &      3.31 & 4.83 & 8.26 &   3.04 & 5.09 & 8.45 \\
\hline \hline
\end{tabular}
\caption{
\label{Tab:bumps}
{\bf Collision induced distortions}.
The RMSD values observed in the small chemotaxis-Y protein (PDB code: {\tt 3chy}) during the collision
of two 8-domain/subunit collisions are tabulated as the minimum, average and maximum values when each
domain is compared pairwise with each other before and after the collision.   Four degrees of collision
severity were tested from a complete {\bf miss} through a glancing blow ({\bf clip}) to a {\bf half} face
collision and finally an almost head-on collision ({\bf full}).    The models were tested both as individual
{\bf subunit}s and as {\bf domains} linked in a Hilbert curve.   The 'loose' C-terminal \AH\ was either
tethered ({\bf link on}) or free ({\bf no link}).    Two parameter combinations were tested with the
{\bf hard:soft} repulsion ratio at both domain and secondary structure levels set to ($a$) 50:20 and ($b$) 
100:20, as a percentage of the unit weight at the atomic level.  The repulsion parameters for the 
highest protein level was held at the lower value of 20:10.
}
\end{table}

%hard:soft = 100:20
%    subunit
%	no link  miss     frame = 990 aa = 19 bb = 32 ab = 0	RMS:  min = 2.369 ave = 2.91038 max = 3.504
%	no link  clip     frame = 390 aa = 12 bb = 11 ab = 3	RMS:  min = 2.501 ave = 3.04747 max = 3.628
%	no link  half     frame = 790 aa = 63 bb = 45 ab = 5	RMS:  min = 2.634 ave = 3.60256 max = 4.835
%	no link  full     frame = 1080 aa = 97 bb = 106 ab = 7	RMS:  min = 3.799 ave = 4.66473 max = 5.485
%
%	link on  miss     frame = 990 aa = 25 bb = 12 ab = 0	RMS:  min = 2.066 ave = 2.75384 max = 3.274
%	link on  clip     frame = 810 aa = 20 bb = 37 ab = 3	RMS:  min = 2.540 ave = 3.08316 max = 3.814
%	link on  half     frame = 780 aa = 49 bb = 55 ab = 8	RMS:  min = 2.358 ave = 3.68389 max = 4.761
%	link on  full     frame = 1060 aa = 107 bb = 98 ab = 8	RMS:  min = 3.525 ave = 4.56773 max = 5.496
%
%    domains
%	no link  miss     frame = 990 aa = 36 bb = 23 ab = 0	RMS:  min = 2.088 ave = 2.93714 max = 4.186
%	no link  clip     frame = 700 aa = 39 bb = 67 ab = 2	RMS:  min = 2.352 ave = 3.64122 max = 5.143
%	no link  half     frame = 1320 aa = 75 bb = 98 ab = 3	RMS:  min = 2.739 ave = 4.40182 max = 7.633
%	no link  full     frame = 1610 aa = 120 bb = 104 ab = 6	RMS:  min = 3.309 ave = 4.83634 max = 8.263
%
%	link on  miss     frame = 990 aa = 25 bb = 34 ab = 0	RMS:  min = 2.269 ave = 3.11580 max = 4.255
%	link on  clip     frame = 1020 aa = 61 bb = 64 ab = 3	RMS:  min = 2.617 ave = 3.79832 max = 5.482
%	link on  half     frame = 1350 aa = 80 bb = 121 ab = 9	RMS:  min = 2.786 ave = 4.37453 max = 6.655
%	link on  full     frame = 990 aa = 85 bb = 108 ab = 3	RMS:  min = 3.041 ave = 5.09632 max = 8.449
%
%hard:soft = 50:20
%    subunit
%	no link  miss     frame = 990 aa = 25 bb = 25 ab = 0	RMS:  min = 2.296 ave = 2.82268 max = 3.324
%	no link  clip     frame = 860 aa = 38 bb = 31 ab = 2	RMS:  min = 2.315 ave = 3.02307 max = 3.688
%	no link  half     frame = 830 aa = 53 bb = 82 ab = 7	RMS:  min = 2.608 ave = 3.82729 max = 5.013
%	no link  full     frame = 350 aa = 10 bb = 5 ab = 5	RMS:  min = 4.195 ave = 5.13120 max = 6.289
%
%	link on  miss     frame = 990 aa = 18 bb = 28 ab = 0	RMS:  min = 2.271 ave = 2.81993 max = 3.483
%	link on  clip     frame = 1010 aa = 37 bb = 35 ab = 2	RMS:  min = 2.616 ave = 3.04413 max = 3.581
%	link on  half     frame = 770 aa = 67 bb = 66 ab = 8	RMS:  min = 2.488 ave = 3.84289 max = 5.183
%	link on  full     frame = 1120 aa = 125 bb = 132 ab = 5	RMS:  min = 3.481 ave = 5.26102 max = 7.018
%
%    domains
%	no link  miss     frame = 990 aa = 37 bb = 22 ab = 0	RMS:  min = 2.400 ave = 3.06962 max = 4.162
%	no link  clip     frame = 1050 aa = 53 bb = 85 ab = 2	RMS:  min = 2.344 ave = 3.72846 max = 5.174
%	no link  half     frame = 1030 aa = 104 bb = 105 ab = 5	RMS:  min = 2.815 ave = 4.45303 max = 6.800
%	no link  full     frame = 370 aa = 13 bb = 18 ab = 3	RMS:  min = 3.749 ave = 5.25678 max = 7.099
%
%	link on  miss     frame = 990 aa = 29 bb = 24 ab = 0	RMS:  min = 2.101 ave = 3.12647 max = 4.451
%	link on  clip     frame = 1190 aa = 64 bb = 77 ab = 3	RMS:  min = 2.870 ave = 3.93120 max = 5.458
%	link on  half     frame = 1130 aa = 91 bb = 94 ab = 3	RMS:  min = 3.027 ave = 4.71534 max = 8.282
%	link on  full     frame = 1400 aa = 135 bb = 120 ab = 7	RMS:  min = 3.717 ave = 5.72397 max = 8.475
%
%

\paragraph{64+64 domain collision:\\}

The next larger complete Hilbert curve of protein domains comprises 64 domains (8256 residues)
and the interaction of two such objects approaches the computational limits of what can be run
on a laptop computer in real time (over a few minutes).   Nevertheless, a small number of test
were conducted with the highest level in the hierarchy consisting of a sphere of unlinked proteins,
each composed of 8 linked domains as employed above.    The $soft:hard$ parameter combination
for this level was again set to 10:5 (percent of atomic).

The mean domain start/final RMSD value after a half-face collision was 6.5\AA.  No inter-object
clashes were seen at the atomic level but a marked number of intra-object clashes built-up
during the collision.   It seemed likely that this higher than expected RMSD value 
was therefore a consequence of the speed of the collision giving insufficient time for the
'shock-wave' of compression to dissipate through the domains. (Figure 3)

The collision was then re-run in 'slow-motion' with a time-step slowed by a factor of 10.
(The collision that normally took a few minutes now took 30).  The mean RMSD then dropped to
the acceptable value of 5.3\AA\ but intra-body clashes were still prominent during the collision.
This was similar to the collision of the largest Hilbert cubes, with the intra-object
collisions absorbing the 'energy' of the crash.

% RMS:  min = 3.422 ave = 5.36615 max = 8.861

\begin{figure}
\centering
\subfigure[]{
\epsfxsize=190pt \epsfbox{figs/prot/bump1.eps}
}
\subfigure[]{
\epsfxsize=190pt \epsfbox{figs/prot/bump2.eps}
}
\subfigure[]{
\epsfxsize=190pt \epsfbox{figs/prot/bump3.eps}
}
\subfigure[]{
\epsfxsize=190pt \epsfbox{figs/prot/bump4.eps}
}
\caption[]{
\label{Fig:bumps}
\begin{footnotesize}
{\bf Multi-domain protein collisions}.  Two 8256 residue chains, aranged as 64 domains each in a
Hilbert curve, are directed into each other.  The frames $a$---$d$ show the progression of the
collision from initial contact to the point where the structures are almost past each other.
Pairs of colliding objects are coloured by their separation in the structural hierarchy (as described
in Figure 1) from green for first-cousins through yellow, red and magenta for inreasing levels or removal.
\end{footnotesize}
}
\end{figure}


\subsection{Distance constraint satisfaction}

In this section two examples are provided using known macromolecules in
which the steric exclusion (collision) parameters identified in the previous section are
combined with a set of distance constraints.
As the previous section used a globular protein structure, an example is
taken firstly of an integral membrane protein to illustrate a different 
combination of objects and secondly of an RNA structure to show how the
different objects can be combined to represent nucleic acid structures.
Predicted distance constraints were derived from the analysis of correlated
mutations.  (See ref.\cite{TaylorWRet13} for a review).

The two examples also illustrate different strategies of constraint
satisfaction.   For the membrane protein, a set of protein-like starting 
structures is generated using a lattice based model \cite{TaylorWRet94a} and the
predicted distance constraints are used essentially for refinement rather
than to rearrange the helix packing.  In this situation, the distance
constraints are introduced progressively in order of their strength
(probability of being correct) and only retained if they initially
fall (and remain) within twice their target distance.   This prevents
inconsistent long range constraints disrupting the model.  By contrast,
the nucleic acid example has no ideal starting structure, except its
(2-dimensional) secondary structure prediction and in this situation,
the top 50 constraints were introduced at the start and gradually culled
if they did not approach their target separation.  

\subsubsection{Rhodopsin}

The first structure of an integral trans-membrane (TM) protein to be determined
was that of bacteriorhodopsin and this protein (PDB code: {\tt 1BRD}) and its
much larger sister family the opsins, which includes the GPCR receptors (eg: PDB code:
{\tt 1GZM}), remains a favourite for testing modelling and prediction methods.

These structures consist of 7-TM helices arranged in a simple bundle
Each was modelled as an \AH\ confined in an tube, as described above for the
small globular protein.   The seven tubes were then contained in a larger
tube which had a diameter narrow enough to confine the helices in a compact
packing arrangement in the plane of the membrane and long enough to allow 
the helices to shift to a reasonable extent up and down relative to the membrane.  
Because the ends of the helical tubes are not constrained to lie within their
containing tube, they are still free to tilt relative to each other, as is
commonly observed in such structures.  (\Fig{rhod-model}).

As an exercise in structure refinement, the helices were allowed to move
under the influence of the pairwise residue constraints derived from the
correlated mutation analysis, starting from a number of configurations
obtained from combinatorial enumeration over a hexagonal lattice \cite{TaylorWRet94a}.
The resulting models were then ranked on how well they had satisfied the
given constraints.  Plotting this score against RMSD (\Fig{rhod-score}),
gave a clear indication for model selection and, as can be seen from the
RMSD values, the highest scoring model was a good prediction (\Fig{rhod-super}).

The method was also applied to a protein of unknown structure, FlhA: which is
a core component in the bacterial flagellum motor (in its type-III secretion 
sub-system) and thought to form a ring of nine proteins (\Fig{flhA-model}).

\begin{figure}
\centering
\subfigure[rhodopsin]{
\label{Fig:rhod-model}
\epsfxsize=140pt \epsfbox{figs/rhod/rhod.eps}
}
\subfigure[FlhA]{
\label{Fig:flhA-model}
\epsfxsize=211pt \epsfbox{figs/rhod/ring.eps}
}
\caption{
\label{Fig:TMmodels}
{\bf Transmembrane proteins} were modelled as \AH\ tubes inside a "kinder-surprise"
confining tube (yellow), the axis of which lies perpendicular to the membrane plane.
$a$) A model of rhodopsin with 7-TM helices.
$b$) A model of the type-III secretion protein FlhA which is predicted to have 8-TM helices
and is thought to form a ring of nine copies in the membrane forming a pore.
}
\end{figure}

\begin{figure}
\centering
\subfigure[Score vs RMSD]{
\label{Fig:rhod-score}
\epsfxsize=270pt \epsfbox{figs/rhod/rmsds.eps}
}
\subfigure[rhodopsin model]{
\label{Fig:rhod-super}
\epsfxsize=120pt \epsfbox{figs/rhod/super.eps}
}
\caption{
\label{Fig:rhod-pred}
{\bf Rhodopsin predictions}
$a$) The RMSD of the predicted models (X-axis) is plotted against how well each model matches
the constraints derived from the correlated mutation analysis (Y-axis: high is good, with
the score of the native structure marked by a green line).
Blue dots are from the current modelling method with red dots calculated by the FILM3
method.  The RMSD is over the TM-helices only.
$b$) The highest scoring rhodopsin model is superposed on the native structure (PDB code {\tt 1GZM}).
Both structures are shown as a virtual \CA\ backbone coloured blue (amino) to red (carboxy)
with the \CA\ positions rendered as small spheres on the predicted structure.
The helices lie close together but deviations can be seen in the loops and at the termini.
}
\end{figure}


\subsubsection{SAM riboswitch}

The structure of the S-adenylate-methionine type-I riboswitch (SAM-I) is a small (94 base) RNA involved
in the control of bacterial gene expression (PDB code:{\tt 2GIS}).   Consensus RNA secondary structure
prediction methods \cite{HofackerIL03} produce a "clover-leaf" structure reminiscent of tRNA, and like that molecule, its
structure can be viewed as two basepaired hairpins (stem-loops) with each being an insertion into the
other.  Unlike the secondary structure prediction, the tertiary structure reveals an additional
short region of base-pairing between the two hairpins (a pseudo-knot) which serves
to lock the 3D structure.   Interestingly, these interactions are clearly predicted
by the correlation analysis and, together with the more 'trivial' base-pairing
correlations, were used as constraints for modelling.

The predicted base-paired regions were set-up as tubes with the phosphates of the paired bases
at either end of a smaller tube forming rungs of a ladder (as described above) and these stem-loops
were then specified to be confined inside a larger sphere.    The flat clover-leaf secondary structure
prediction was taken as a starting position for each phosphate (\Fig{ribo0}) and under the
influence of the confining pull (to move inside the central sphere), their bonded phosphates
and the imposed distance constraints, the stem-loops moved inwards quickly (\Fig{ribo1} and (c))
and packed to best accommodate the constraints (\Fig{ribo3}).    As not all the constraints can be
simultaneously satisfied (due to prediction error), once inside the sphere,
the longest constraints were gradually culled (with a stochastic bias to retain the
strongest and those not within a stem-loop).   By the end of a short run, a compact
structure remained and, as with the TM-protein predictions, after many runs the structures
were ranked on how well they satisfied the constraints.

\begin{figure}
\centering
\subfigure[0]{
\label{Fig:ribo0}
\epsfxsize=212pt \epsfbox{figs/ribo/rna0.eps}
}
\subfigure[5]{
\label{Fig:ribo1}
\epsfxsize=178pt \epsfbox{figs/ribo/rna1.eps}
}
\subfigure[20]{
\label{Fig:ribo2}
\epsfxsize=220pt \epsfbox{figs/ribo/rna2.eps}
}
\subfigure[100]{
\label{Fig:ribo3}
\epsfxsize=171pt \epsfbox{figs/ribo/rna5.eps}
}
\caption{
\label{Fig:myo2DFS}
{\bf SAM riboswitch simulation} in which the phosphate backbone (silver) is linked by
thin green tube when basepaired (or cyan for loops) with basepaired regions (stem-loops)
contained inside red tubes.  The blue central sphere is the target volume inside which
stem-loops aim to be contained.   At the start ($a$, time 0), the phosphates are in their
flat predicted secondary structure positions.   Thin lines link pairs of phosphates with
a target distance constraint with most corresponding to basepaired nucleotides.
The system is simulated with random, but decreasing motion, applied to the stem-loop tubes
and the structure moves rapidly to a packed conformation inside the target sphere
(frames $b$ to $d$).    
}
\end{figure}

The packing of four stem-loops has only two distinct spatial arrangements corresponding to
the left and right enantiomers of a tetrahedral configuration.   However, the connections 
between consecutive stem loops are not restricted, leading to many possible topologies
(some of which are knotted).   Plotting the constraint score against RMSD revealed a
small but distinct bias of higher scoring models to have lower RMSDs, especially when
models containing excessive P-P clashes were excluded.

However, comparing the higher scoring models against the known structure, differences
were found in the orientation of the halves of stem-loops either side of the mutual
"insertion" point.  In the native structure the two halves of the stems are aligned but
in most models the halves have a kinked alignment as there is little in the model to
direct their packing away from a tetrahedral juxtaposition.   While this difference
accounts for most of the deviation, more importantly, even the models with the lowest 
RMSD had a topological differences from the native.     

It seemed likely that this topological error may have its roots in the restricted
clover-leaf starting configuration.   If all cyclic permutations of the stems around the
leaf are considered, then, allowing for symmetry, there is only one other possible
configuration in which two stems have been switched and this configuration
also reduces the separation of the pseudo-knot distance constraints.  This new starting
model produced a much more distinct skew towards high-scoring, low RMSD models
(\Fig{ribo-score}) however, the best models, despite having the correct juxtaposition
of the stem-loops, still retained the same topological error.  (Figure 7(b)).
A more detailed analysis of this problem will be considered more fully elsewhere.

\begin{figure}
\centering
\subfigure[]{
\label{Fig:ribo-score}
\epsfxsize=235pt \epsfbox{figs/ribo/score.eps}
}
\subfigure[]{
\label{Fig:ribo-model}
\epsfxsize=155pt \epsfbox{figs/ribo/best.eps}
}
\caption{
\label{Fig:ribo}
{\bf SAM riboswitch models:} $a$) are scored by how well they fit the top 50 constraints
and this value (Y-axis) is plotted against the RMSD of the model from the known structure.
The blue dots mark models that started from the 'default' secondary structure layout
(Figure 6a) and the red dots started from the alternative arrangement with two stemloops
(top and right) in swapped positions.
$b$) The phosphate backbone of a high scoring model (ball and stick) is superposed on the 
known structure (stick).  Both chains are coloured blue ($5'$) to red ($3'$).
The cyan and yellow segments (towards the front) incorporate the long-range links that
form the pseudo-knot.
}
\end{figure}

\clearpage
\section{Summary and Discussion}

\subsection{Summary}

The behaviour of the current method has been investigated using two distinct
approaches: in the examples involving collisions, a constant driving displacement
was applied to a single high-level object (to force it to make contact with 
another object), by contrast,  in the examples involving constraint satisfaction the 
displacements were instead applied to the lowest level objects ("atoms").  In the first
case, the response of the lower level objects to maintain structural integrity was monitored
whereas in the second, the resulting rearrangement of the higher levels objects was of interest.

\subsubsection{Collision algorithms}

The algorithm described in this work for the interaction of a hierarchy of objects
seeks to circumvent a fundamental problem in coarse-grained modelling which
is the loss of fine detail when components become 'bundled' together.
The "currants-in-jelly" model developed here provides a flexible approach in which
the contribution of the soft high-level objects (jelly-like) can be controlled
to protect the underlying atomic structure (currants) while still allowing
them to interact.

Idealised macromolecular chains were used to establish the parameters
to achieve this degree of interaction over a hierarchy spanning four levels.
In a more realistic example using a small globular protein, the extent of the 
distortion experienced by the protein domain structure during collision was then 
examined and the parameters refined to allow an acceptable degree of deformation.

\subsubsection{Constraint satisfaction}

The model of steric repulsion established for idealised systems was then
combined with sets of predicted distance constraints, derived from correlated
mutation analysis,  in two differing applications.    Firstly, an integral
trans-membrane protein was modelled in which the packing of the seven
helices was refined but without topological rearrangement.  Secondly,
an RNA structure was 'folded' under the predicted constraints, starting only
from its 2-dimensional secondary structure prediction.

From the large sequence alignment available for the membrane protein, high
quality distance predictions could be obtained, which combined with good
starting configurations (provided by a simplified lattice model) led to 
the production of high-scoring models with a low RMSD to the known structure.
By contrast, the RNA structure predictions had high RMSD values and although
the stem-loops were correctly located in the higher-scoring models, topological
differences remained which may be a result of constraints imposed by the
flat starting conformation.

\subsection{Limitations and potential}

Whilst the methods and parameters established here have been shown to be
effective, it is unlikely that they are optimal and many aspects of the
model remain to be explored.    The approach taken above was to pick
reasonable values for the extent and strength of an interaction and test
a few variations and combinations in the surrounding parameter-space.
A more systematic approach is needed, and for this the speed of the current
method is a great advantage as many simulations can be run, allowing the
parameter space to be more fully explored and optimal combinations found
for different types of macromolecule.

An earlier, simpler, version of the current method was used to model the
dynamic interaction of actin and myosin.   However, because the atomic (residue)
surfaces did not interact directly in that model, artificial constraints had
to be added to drive the molecular recognition events.  In the current
method, the residue-level surfaces can now come in contact, allowing a more
realistic representation of molecular recognition based on steric compatibility.
However, without a proper atomic interaction potential, the recognition of 
a binding event would still rely on external knowledge of the residues involved.

It was assumed that the parameters used at the start of the simulation remained
the same throughout and equal for all components independently of their
position or interactions.   However, all these aspects could be varied and
if there is a pair of objects that interact preferentially, their parameters
can be set to allow their surfaces to meet whereas others might present a
hard-shell repulsion.  For example, in the actin/myosin example mentioned
above, the actin monomers close to the myosin head could allow atomic
interactions whereas all other interactions retain a high-level repulsion.

The effectiveness of the approach relies on having a rich multi-layer
hierarchy of substructures.   Fortunately, as seen from the varied examples
provided, this is the prevalent situation for the majority of biological
macromolecules.   In the simulation of more homogeneous materials, such
as water, it is unlikely that the approach would be useful.  Similarly, for
a long chain, such as DNA, although segments can be grouped like a string
of sausages, the interaction of two such chains would require evaluation
of the all pairs of sausages.

In large molecules, especially those composed of subunits, the components may not
remain the same throughout a simulation and during an interaction, one subunit may
be transferred to another assembly or a large multi-domain chain may be cleaved.
In its current formulation, the program does not accommodate this, however, such
events could easily be incorporated simply by updating the list of children held
by each object or adding new children to the list. 

\subsection{Relationship to other methods}

As outlined in the Introduction, the current method lies somewhere between a
hierarchical bounding box approach \cite{TeschnerMet05} and the neighbour-list
approaches more commonly found in conventional molecular dynamics.   Although improvements
have been made since their original implementation \cite{VerletL67}, such as the cell-based
algorithm \cite{YaoZet04},  the neighbour-list approach requires the lists to be updated frequently
which involves considerable "book-keeping", especially for objects of different shapes
and sizes \cite{DonevAet05,MuthBet07}.   By contrast in the current method, the 
neighbour-list is a fixed hierarchy in which the lower levels are only evaluated
when higher levels collide. 

Given a model in which all the constraints have been chosen well to avoid bond
or bump violations at all levels, then in the absence of any user applied displacements,
the behaviour of the current method is to do nothing.
It is left entirely up to the user how things should move, which is done by implementing
custom code in what is called the "driver" routine.    This code can be either very
simple, such as the few lines of code needed to implement the collision displacement or
quite complicated such as the code to apply the distance constraints described in the
Results section.

Extrapolating this progression, the constraints could be applied in the form of a potential and
indeed a potential could even be applied to many pairs of atoms \cite{PerioleXet09}.   The next
obvious step would be to implement full molecular dynamics, Lagrangian mechanics or Monte Carlo.
However, the problem with implementing anything complicated in the driver routine is that at some
point, the current method will start to act on the (common) coordinates and if the
driver code requires consistency in terms of distances and derived potentials, forces and
velocities, then a multitude of problems will arise.

The simplest approach to this problem is to attach a warning notice stating that \NAME\ cannot
be used in combination with any method that requires global internal consistency.   The only
route that might avoid this incompatibility would be through a more stochastic approach
in which the displacements made at all levels are treated as a (semi) random Monte Carlo
move of the system, which is similar to the the approach of Sim {\em et al.} \cite{SimAYLet12b},
or perhaps exploiting the hierarchic organisation along the lines of Gipson {\em et al.} \cite{GipsonBet13}.
A second path to resolve the problem might be through a variation of Gaussian elastic
networks \cite{ZhangZet09}.  However, elastic
networks require a fixed topology that cannot be expected to remain intact across the
large (driven) displacements envisaged for the current method.

These possible developments will be reconsidered at a later time as it is currently
unclear, not only how a consistent potential could be applied but also how potentials
on different levels should interact.

\subsection{Conclusion}

The method developed here provides a fast and flexible way to capture the
structure of most macromolecules in a hierarchy of increasingly larger coarse-grained
levels without losing the detailed low-level representation.   Although much testing
remains to be done, the system has the potential to be applied to very large dynamic
systems including both protein and nucleic acids.

\clearpage
\bibliography{latex/newrefs,extra}

\subsection*{Acknowledgements}
Enrico Spiga is thanked for comments on the manuscript.
This work was supported by the Francis Crick Institute which receives its core funding
from Cancer Research UK, the UK Medical Research Council, and the Wellcome Trust.

\end{document}
